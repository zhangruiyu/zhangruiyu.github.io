<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>My New Post | 张大头的博客 | 😝😝😝😝😝😝😝😝😝😝😝😝😝😝😝😝</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="sql,java">
    <meta name="description" content="BeetlSQL2.8中文文档  作者: 闲大赋,Gavin.King,Sue,Zhoupan,woate,Darren 社区 http://ibeetl.com qq群 219324263 当前版本 2.8.9   1. BeetlSQL 特点BeetSql是一个全功能DAO工具， 同时具有Hibernate 优点 &amp;amp; Mybatis优点功能，适用于承认以SQL为中心，同时又需求工具能自">
<meta name="keywords" content="sql,java">
<meta property="og:type" content="article">
<meta property="og:title" content="My New Post">
<meta property="og:url" content="http://yoursite.com/2017/04/19/beetlsql/index.html">
<meta property="og:site_name" content="张大头的博客">
<meta property="og:description" content="BeetlSQL2.8中文文档  作者: 闲大赋,Gavin.King,Sue,Zhoupan,woate,Darren 社区 http://ibeetl.com qq群 219324263 当前版本 2.8.9   1. BeetlSQL 特点BeetSql是一个全功能DAO工具， 同时具有Hibernate 优点 &amp;amp; Mybatis优点功能，适用于承认以SQL为中心，同时又需求工具能自">
<meta property="og:image" content="http://yoursite.com/2017/04/19/beetlsql/static/beetlsql1.png">
<meta property="og:updated_time" content="2017-04-19T12:55:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My New Post">
<meta name="twitter:description" content="BeetlSQL2.8中文文档  作者: 闲大赋,Gavin.King,Sue,Zhoupan,woate,Darren 社区 http://ibeetl.com qq群 219324263 当前版本 2.8.9   1. BeetlSQL 特点BeetSql是一个全功能DAO工具， 同时具有Hibernate 优点 &amp;amp; Mybatis优点功能，适用于承认以SQL为中心，同时又需求工具能自">
<meta name="twitter:image" content="http://yoursite.com/2017/04/19/beetlsql/static/beetlsql1.png">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">张瑞宇</h5>
          <a href="mailto:634206017@qq.com" title="634206017@qq.com" class="mail">634206017@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/yscoder" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://www.weibo.com/ysweb" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/custom"  >
                <i class="icon icon-lg icon-link"></i>
                测试
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">My New Post</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">My New Post</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-04-19T12:03:55.000Z" itemprop="datePublished" class="page-time">
  2017-04-19
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#BeetlSQL2-8中文文档"><span class="post-toc-number">1.</span> <span class="post-toc-text">BeetlSQL2.8中文文档</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-BeetlSQL-特点"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">1. BeetlSQL 特点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-5分钟例子"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">2. 5分钟例子</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1-安装"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">2.1. 安装</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2-准备工作"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">2.2. 准备工作</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3-代码例子"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">2.3. 代码例子</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-4-SQL文件例子"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">2.4. SQL文件例子</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-5-代码-amp-sql生成"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">2.5. 代码&sql生成</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#注意"><span class="post-toc-number">1.2.6.</span> <span class="post-toc-text">注意</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#注意-1"><span class="post-toc-number">1.2.7.</span> <span class="post-toc-text">注意</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-BeetlSQL-说明"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">3. BeetlSQL 说明</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1-获得SQLManager"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">3.1. 获得SQLManager</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2-查询API"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">3.2. 查询API</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-2-1-模板类查询（自动生成sql）"><span class="post-toc-number">1.3.2.1.</span> <span class="post-toc-text">3.2.1. 模板类查询（自动生成sql）</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-2-2-通过sqlid查询-sql语句在md文件里"><span class="post-toc-number">1.3.2.2.</span> <span class="post-toc-text">3.2.2. 通过sqlid查询,sql语句在md文件里</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-3-翻页查询API"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">3.3. 翻页查询API</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#跨数据库支持"><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">跨数据库支持</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-4-更新API"><span class="post-toc-number">1.3.5.</span> <span class="post-toc-text">3.4. 更新API</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-4-1-自动生成sql"><span class="post-toc-number">1.3.5.1.</span> <span class="post-toc-text">3.4.1. 自动生成sql</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-4-2-通过sqlid更新（删除）"><span class="post-toc-number">1.3.5.2.</span> <span class="post-toc-text">3.4.2. 通过sqlid更新（删除）</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-5-直接执行SQL模板"><span class="post-toc-number">1.3.6.</span> <span class="post-toc-text">3.5. 直接执行SQL模板</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-5-1-直接执行sql模板语句"><span class="post-toc-number">1.3.6.1.</span> <span class="post-toc-text">3.5.1. 直接执行sql模板语句</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-5-2-直接执行JDBC-sql语句"><span class="post-toc-number">1.3.7.</span> <span class="post-toc-text">3.5.2. 直接执行JDBC sql语句</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-6-其他"><span class="post-toc-number">1.3.8.</span> <span class="post-toc-text">3.6. 其他</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-6-1-强制使用主或者从"><span class="post-toc-number">1.3.8.1.</span> <span class="post-toc-text">3.6.1. 强制使用主或者从</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-6-2-生成Pojo代码和SQ片段"><span class="post-toc-number">1.3.8.2.</span> <span class="post-toc-text">3.6.2. 生成Pojo代码和SQ片段</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#警告"><span class="post-toc-number">1.3.9.</span> <span class="post-toc-text">警告</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-命名转化，表和列名映射"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">4. 命名转化，表和列名映射</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-复合主键"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">5. 复合主键</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-使用Mapper"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">6. 使用Mapper</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-BeetlSQL-Annotation"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">7. BeetlSQL Annotation</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-1-AutoID-和-AssignID-，-SeqID"><span class="post-toc-number">1.7.1.</span> <span class="post-toc-text">7.1. @AutoID 和 @AssignID ，@SeqID</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#备注"><span class="post-toc-number">1.7.2.</span> <span class="post-toc-text">备注</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-2-Tail"><span class="post-toc-number">1.7.3.</span> <span class="post-toc-text">7.2. @Tail</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-3-ColumnIgnore"><span class="post-toc-number">1.7.4.</span> <span class="post-toc-text">7.3. @ColumnIgnore</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-4-EnumMapping"><span class="post-toc-number">1.7.5.</span> <span class="post-toc-text">7.4. @EnumMapping</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-5-Table"><span class="post-toc-number">1.7.6.</span> <span class="post-toc-text">7.5. @Table</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-6-TableTemplate"><span class="post-toc-number">1.7.7.</span> <span class="post-toc-text">7.6. @TableTemplate</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#注意-2"><span class="post-toc-number">1.7.8.</span> <span class="post-toc-text">注意</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-7-Mapper相关注解"><span class="post-toc-number">1.7.9.</span> <span class="post-toc-text">7.7. Mapper相关注解</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#7-8-ORMQuery"><span class="post-toc-number">1.7.10.</span> <span class="post-toc-text">7.8. ORMQuery</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-BeetlSQL-数据模型"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">8. BeetlSQL 数据模型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#9-Markdown方式管理"><span class="post-toc-number">1.9.</span> <span class="post-toc-text">9. Markdown方式管理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#注"><span class="post-toc-number">1.9.1.</span> <span class="post-toc-text">注</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#10-SQL-注释"><span class="post-toc-number">1.10.</span> <span class="post-toc-text">10. SQL 注释</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#11-重要-配置beetlsql"><span class="post-toc-number">1.11.</span> <span class="post-toc-text">11. (重要) 配置beetlsql</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#11-1-开发模式和产品模式"><span class="post-toc-number">1.11.1.</span> <span class="post-toc-text">11.1. 开发模式和产品模式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#11-2-NameConversion"><span class="post-toc-number">1.11.2.</span> <span class="post-toc-text">11.2. NameConversion</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#11-3-模板字符集"><span class="post-toc-number">1.11.3.</span> <span class="post-toc-text">11.3. 模板字符集</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#11-4-翻页起始参数是0还是1"><span class="post-toc-number">1.11.4.</span> <span class="post-toc-text">11.4. 翻页起始参数是0还是1</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#11-5-自定义方法和标签函数"><span class="post-toc-number">1.11.5.</span> <span class="post-toc-text">11.5. 自定义方法和标签函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#11-6-isEmpty-和-isNotEmpty"><span class="post-toc-number">1.11.6.</span> <span class="post-toc-text">11.6. isEmpty 和 isNotEmpty</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#12-SQL-模板基于Beetl实现"><span class="post-toc-number">1.12.</span> <span class="post-toc-text">12. SQL 模板基于Beetl实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#13-Beetl-入门"><span class="post-toc-number">1.13.</span> <span class="post-toc-text">13. Beetl 入门</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-1-定界符号"><span class="post-toc-number">1.13.1.</span> <span class="post-toc-text">13.1. 定界符号</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-2-变量"><span class="post-toc-number">1.13.2.</span> <span class="post-toc-text">13.2. 变量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-3-算数表达式"><span class="post-toc-number">1.13.3.</span> <span class="post-toc-text">13.3. 算数表达式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-4-逻辑表达式"><span class="post-toc-number">1.13.4.</span> <span class="post-toc-text">13.4. 逻辑表达式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-5-控制语句"><span class="post-toc-number">1.13.5.</span> <span class="post-toc-text">13.5. 控制语句</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#注意-3"><span class="post-toc-number">1.13.6.</span> <span class="post-toc-text">注意</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-6-访问变量属性"><span class="post-toc-number">1.13.7.</span> <span class="post-toc-text">13.6. 访问变量属性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-7-判断对象非空空"><span class="post-toc-number">1.13.8.</span> <span class="post-toc-text">13.7. 判断对象非空空</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-8-调用方法"><span class="post-toc-number">1.13.9.</span> <span class="post-toc-text">13.8. 调用方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-9-自定义方法"><span class="post-toc-number">1.13.10.</span> <span class="post-toc-text">13.9. 自定义方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-10-内置方法"><span class="post-toc-number">1.13.11.</span> <span class="post-toc-text">13.10. 内置方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#13-11-标签功能"><span class="post-toc-number">1.13.12.</span> <span class="post-toc-text">13.11. 标签功能</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#14-Debug功能"><span class="post-toc-number">1.14.</span> <span class="post-toc-text">14. Debug功能</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#15-缓存功能"><span class="post-toc-number">1.15.</span> <span class="post-toc-text">15. 缓存功能</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#16-Interceptor功能"><span class="post-toc-number">1.16.</span> <span class="post-toc-text">16. Interceptor功能</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#17-内置支持主从数据库"><span class="post-toc-number">1.17.</span> <span class="post-toc-text">17. 内置支持主从数据库</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#18-可以支持更复杂的分库分表逻辑"><span class="post-toc-number">1.18.</span> <span class="post-toc-text">18. 可以支持更复杂的分库分表逻辑</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#注意-4"><span class="post-toc-number">1.18.1.</span> <span class="post-toc-text">注意</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#19-跨数据库平台"><span class="post-toc-number">1.19.</span> <span class="post-toc-text">19. 跨数据库平台</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#20-代码生成"><span class="post-toc-number">1.20.</span> <span class="post-toc-text">20. 代码生成</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#20-1-生成pojo-和-md文件"><span class="post-toc-number">1.20.1.</span> <span class="post-toc-text">20.1. 生成pojo 和 md文件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#20-2-生成更多的代码"><span class="post-toc-number">1.20.2.</span> <span class="post-toc-text">20.2. 生成更多的代码</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#21-直接使用SQLResult"><span class="post-toc-number">1.21.</span> <span class="post-toc-text">21. 直接使用SQLResult</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#22-Hibernate-MyBatis-BeetlSQL-对比"><span class="post-toc-number">1.22.</span> <span class="post-toc-text">22. Hibernate,MyBatis,BeetlSQL 对比</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#23-ORM"><span class="post-toc-number">1.23.</span> <span class="post-toc-text">23. ORM</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#注意-5"><span class="post-toc-number">1.23.1.</span> <span class="post-toc-text">注意</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#23-1-sql语句里的ORM查询"><span class="post-toc-number">1.23.2.</span> <span class="post-toc-text">23.1. sql语句里的ORM查询</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#注意-6"><span class="post-toc-number">1.23.3.</span> <span class="post-toc-text">注意</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#23-2-ORM-注解"><span class="post-toc-number">1.23.4.</span> <span class="post-toc-text">23.2. ORM 注解</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#24-集成和Demo"><span class="post-toc-number">1.24.</span> <span class="post-toc-text">24. 集成和Demo</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#24-1-Spring集成和Demo"><span class="post-toc-number">1.24.1.</span> <span class="post-toc-text">24.1. Spring集成和Demo</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#参考"><span class="post-toc-number">1.24.2.</span> <span class="post-toc-text">参考</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#24-2-SpringBoot集成"><span class="post-toc-number">1.24.3.</span> <span class="post-toc-text">24.2. SpringBoot集成</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#24-3-JFinal集成和Demo"><span class="post-toc-number">1.24.4.</span> <span class="post-toc-text">24.3. JFinal集成和Demo</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#注意-7"><span class="post-toc-number">1.24.5.</span> <span class="post-toc-text">注意</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#参考-1"><span class="post-toc-number">1.24.6.</span> <span class="post-toc-text">参考</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#25-高级部分"><span class="post-toc-number">1.25.</span> <span class="post-toc-text">25. 高级部分</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#25-1-ResultSet结果集到Bean的转化"><span class="post-toc-number">1.25.1.</span> <span class="post-toc-text">25.1. ResultSet结果集到Bean的转化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#25-2-ResultSet结果集到Map的转化"><span class="post-toc-number">1.25.2.</span> <span class="post-toc-text">25.2. ResultSet结果集到Map的转化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#25-3-PreparedStatment"><span class="post-toc-number">1.25.3.</span> <span class="post-toc-text">25.3. PreparedStatment</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#25-4-自定义BeanProcessor"><span class="post-toc-number">1.25.4.</span> <span class="post-toc-text">25.4. 自定义BeanProcessor</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#25-5-事务管理"><span class="post-toc-number">1.25.5.</span> <span class="post-toc-text">25.5. 事务管理</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-beetlsql"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">My New Post</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-04-19 20:03:55" datetime="2017-04-19T12:03:55.000Z"  itemprop="datePublished">2017-04-19</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="BeetlSQL2-8中文文档"><a href="#BeetlSQL2-8中文文档" class="headerlink" title="BeetlSQL2.8中文文档"></a>BeetlSQL2.8中文文档</h2><blockquote>
<ul>
<li>作者: 闲大赋,Gavin.King,Sue,Zhoupan,woate,Darren</li>
<li>社区 <a href="http://ibeetl.com/" target="_blank" rel="external">http://ibeetl.com</a></li>
<li>qq群 219324263</li>
<li>当前版本 2.8.9</li>
</ul>
</blockquote>
<h3 id="1-BeetlSQL-特点"><a href="#1-BeetlSQL-特点" class="headerlink" title="1. BeetlSQL 特点"></a>1. BeetlSQL 特点</h3><p>BeetSql是一个全功能DAO工具， 同时具有Hibernate 优点 &amp; Mybatis优点功能，适用于承认以SQL为中心，同时又需求工具能自动能生成大量常用的SQL的应用。</p>
<ul>
<li>开发效率<ul>
<li>无需注解，自动使用大量内置SQL，轻易完成增删改查功能，节省50%的开发工作量</li>
<li>数据模型支持Pojo，也支持Map/List这种快速模型，也支持混合模型</li>
<li>SQL 模板基于Beetl实现，更容易写和调试，以及扩展</li>
<li>可以针对单个表(或者视图）代码生成pojo类和sql模版，甚至是整个数据库。能减少代码编写工作量</li>
</ul>
</li>
<li>维护性<ul>
<li>SQL 以更简洁的方式，Markdown方式集中管理，同时方便程序开发和数据库SQL调试。</li>
<li>可以自动将sql文件映射为dao接口类</li>
<li>灵活直观的支持支持一对一，一对多，多对多关系映射而不引入复杂的OR Mapping概念和技术。</li>
<li>具备Interceptor功能，可以调试，性能诊断SQL，以及扩展其他功能</li>
</ul>
</li>
<li>其他<ul>
<li>内置支持主从数据库支持的开源工具</li>
<li>支持跨数据库平台，开发者所需工作减少到最小，目前跨数据库支持mysql,postgres,oracle,sqlserver,h2,sqllite,DB2.</li>
</ul>
</li>
</ul>
<h3 id="2-5分钟例子"><a href="#2-5分钟例子" class="headerlink" title="2. 5分钟例子"></a>2. 5分钟例子</h3><h4 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1. 安装"></a>2.1. 安装</h4><p>maven 方式:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ibeetl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>beetlsql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>或者依次下载beetlsql，beetl 最新版本 包放到classpath里</p>
<h4 id="2-2-准备工作"><a href="#2-2-准备工作" class="headerlink" title="2.2. 准备工作"></a>2.2. 准备工作</h4><p>为了快速尝试BeetlSQL，需要准备一个Mysql数据库或者其他任何beetlsql支持的数据库，然后执行如下sql脚本</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</div><div class="line">	  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</div><div class="line">	  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">	  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">	  <span class="string">`userName`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户名称'</span>,</div><div class="line">	  <span class="string">`roleId`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户角色'</span>,</div><div class="line">	  <span class="string">`create_date`</span> datetime <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">	  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</div></pre></td></tr></table></figure>
<p>编写一个Pojo类，与数据库表对应（或者可以通过SQLManager的gen方法生成此类，参考一下节）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.math.*;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">*</div><div class="line">* gen by beetlsql 2016-01-06</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>  </span>&#123;</div><div class="line">	<span class="keyword">private</span> Integer id ;</div><div class="line">	<span class="keyword">private</span> Integer age ;</div><div class="line">	<span class="comment">//用户角色</span></div><div class="line">	<span class="keyword">private</span> Integer roleId ;</div><div class="line">	<span class="keyword">private</span> String name ;</div><div class="line">	<span class="comment">//用户名称</span></div><div class="line">	<span class="keyword">private</span> String userName ;</div><div class="line">	<span class="keyword">private</span> Date createDate ;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>主键需要通过注解来说明，如@AutoID，或者@AssingID等，但如果是自增主键，且属性是名字是id，则不需要注解，自动认为是自增主键</p>
</blockquote>
<h4 id="2-3-代码例子"><a href="#2-3-代码例子" class="headerlink" title="2.3. 代码例子"></a>2.3. 代码例子</h4><p>写一个java的Main方法，内容如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">ConnectionSource source = ConnectionSourceHelper.getSimple(driver, url, userName, password);</div><div class="line">DBStyle mysql = <span class="keyword">new</span> MySqlStyle();</div><div class="line"><span class="comment">// sql语句放在classpagth的/sql 目录下</span></div><div class="line">SQLLoader loader = <span class="keyword">new</span> ClasspathLoader(<span class="string">"/sql"</span>);</div><div class="line"><span class="comment">// 数据库命名跟java命名一样，所以采用DefaultNameConversion，还有一个是UnderlinedNameConversion，下划线风格的，</span></div><div class="line">UnderlinedNameConversion nc = <span class="keyword">new</span>  UnderlinedNameConversion();</div><div class="line"><span class="comment">// 最后，创建一个SQLManager,DebugInterceptor 不是必须的，但可以通过它查看sql执行情况</span></div><div class="line">SQLManager sqlManager = <span class="keyword">new</span> SQLManager(mysql,loader,source,nc,<span class="keyword">new</span> Interceptor[]&#123;<span class="keyword">new</span> DebugInterceptor()&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//使用内置的生成的sql 新增用户，如果需要获取主键，可以传入KeyHolder</span></div><div class="line">User user = <span class="keyword">new</span> User();</div><div class="line">user.setAge(<span class="number">19</span>);</div><div class="line">user.setName(<span class="string">"xiandafu"</span>);</div><div class="line">sqlManager.insert(user);</div><div class="line"></div><div class="line"><span class="comment">//使用内置sql查询用户</span></div><div class="line"><span class="keyword">int</span> id = <span class="number">1</span>;</div><div class="line">user = sqlManager.unique(User.class,id);</div><div class="line"></div><div class="line"><span class="comment">//模板更新,仅仅根据id更新值不为null的列</span></div><div class="line">User newUser = <span class="keyword">new</span> User();</div><div class="line">newUser.setId(<span class="number">1</span>);</div><div class="line">newUser.setAge(<span class="number">20</span>);</div><div class="line">sqlManager.updateTemplateById(newUser);</div><div class="line"></div><div class="line"><span class="comment">//模板查询</span></div><div class="line">User query = <span class="keyword">new</span> User();</div><div class="line">query.setName(<span class="string">"xiandafu"</span>);</div><div class="line">List&lt;User&gt; list = sqlManager.template(query);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//使用user.md 文件里的select语句，参考下一节。</span></div><div class="line">User query2 = <span class="keyword">new</span> User();</div><div class="line">query.setName(<span class="string">"xiandafu"</span>);</div><div class="line">List&lt;User&gt; list2 = sqlManager.select(<span class="string">"user.select"</span>,User.class,query2);</div></pre></td></tr></table></figure>
<h4 id="2-4-SQL文件例子"><a href="#2-4-SQL文件例子" class="headerlink" title="2.4. SQL文件例子"></a>2.4. SQL文件例子</h4><p>通常一个项目还是有少量复杂sql，可能只有5，6行，也可能有上百行，放在单独的sql文件里更容易编写和维护，为了能执行上例的user.select,需要在classpath里建立一个sql目录（在src目录下建立一个sql目录，或者maven工程的resources目录。ClasspathLoader 配置成sql目录，参考上一节ClasspathLoader初始化的代码）以及下面的user.md 文件，内容如下</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="section">select</span></div><div class="line">===</div><div class="line">select * from user where 1=1</div><div class="line">@if(!isEmpty(age))&#123;</div><div class="line">and age = #age#</div><div class="line">@&#125;</div><div class="line">@if(!isEmpty(name))&#123;</div><div class="line">and name = #name#</div><div class="line">@&#125;</div></pre></td></tr></table></figure>
<p>关于如何写sql模板，会稍后章节说明，如下是一些简单说明。</p>
<ul>
<li>采用md格式，===上面是sql语句在本文件里的唯一标示，下面则是sql语句。</li>
<li>@ 和回车符号是定界符号，可以在里面写beetl语句。</li>
<li>“#” 是占位符号，生成sql语句得时候，将输出？，如果你想输出表达式值，需要用text函数，或者任何以db开头的函数，引擎则认为是直接输出文本。</li>
<li>isEmpty是beetl的一个函数，用来判断变量是否为空或者是否不存在.</li>
<li>文件名约定为类名，首字母小写。</li>
</ul>
<p>sql模板采用beetl原因是因为beetl 语法类似js，且对模板渲染做了特定优化，相比于mybatis，更加容易掌握和功能强大，可读性更好，也容易在java和数据库之间迁移sql语句</p>
<hr>
<p>注意：sqlId 到sql文件的映射是通过类SQLIdNameConversion来完成的，默认提供了DefaultSQLIdNameConversion实现，即 以 “.” 区分最后一部分是sql片段名字，前面转为为文件相对路径，如sqlId是user.select，则select是sql片段名字，user是文件名，beetlsql会在根目录下寻找/user.sql,/user.md ,也会找数据库方言目录下寻找，比如如果使用了mysql数据库，则优先寻找/mysql/user.md,/mysql/user.sql 然后在找/user.md,/user.sql.</p>
<p>如果sql是 test.user.select,则会在/test/user.md(sql) 或者 /mysql/test/user.md(sql) 下寻找“select”片段</p>
<h4 id="2-5-代码-amp-sql生成"><a href="#2-5-代码-amp-sql生成" class="headerlink" title="2.5. 代码&amp;sql生成"></a>2.5. 代码&amp;sql生成</h4><p>User类并非需要自己写，好的实践是可以在项目中专门写个类用来辅助生成pojo和sql片段，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">	SqlManager sqlManager  = ...... <span class="comment">//同上面的例子</span></div><div class="line">	sqlManager.genPojoCodeToConsole(<span class="string">"user"</span>);</div><div class="line">	sqlManager.genSQLTemplateToConsole(<span class="string">"user"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>  注意:我经常在我的项目里写一个这样的辅助类，用来根据表或者视图生成各种代码和sql片段，以快速开发.</p>
</blockquote>
<p>genPojoCodeToConsole 方法可以根据数据库表生成相应的Pojo代码，输出到控制台，开发者可以根据这些代码创建相应的类，如上例子，控制台将输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test;</div><div class="line"><span class="keyword">import</span> java.math.*;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.sql.Timestamp;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">*</div><div class="line">* gen by beetlsql 2016-01-06</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>  </span>&#123;</div><div class="line">	<span class="keyword">private</span> Integer id ;</div><div class="line">	<span class="keyword">private</span> Integer age ;</div><div class="line">	<span class="comment">//用户角色</span></div><div class="line">	<span class="keyword">private</span> Integer roleId ;</div><div class="line">	<span class="keyword">private</span> String name ;</div><div class="line">	<span class="comment">//用户名称</span></div><div class="line">	<span class="keyword">private</span> String userName ;</div><div class="line">	<span class="keyword">private</span> Date createDate ;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>  生成属性的时候，id总是在前面，后面依次是类型为Integer的类型，最后面是日期类型，剩下的按照字母排序放到中间。</p>
</blockquote>
<p>一旦有了User 类，如果你需要些sql语句，那么genSQLTemplateToConsole 将是个很好的辅助方法，可以输出一系列sql语句片段，你同样可以赋值粘贴到代码或者sql模板文件里（user.md),如上例所述，当调用genSQLTemplateToConsole的时候，生成如下</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="section">sample</span></div><div class="line">===</div><div class="line"><span class="bullet">* </span>注释</div><div class="line"></div><div class="line"><span class="code">	select #use("cols")# from user where #use("condition")#</span></div><div class="line"></div><div class="line"><span class="section">cols</span></div><div class="line">===</div><div class="line"></div><div class="line"><span class="code">	id,name,age,userName,roleId,create_date</span></div><div class="line"></div><div class="line"><span class="section">updateSample</span></div><div class="line">===</div><div class="line"></div><div class="line"><span class="code">	`id`=#id#,`name`=#name#,`age`=#age#,`userName`=#userName#,`roleId`=#roleId#,`create_date`=#date#</span></div><div class="line"></div><div class="line"><span class="section">condition</span></div><div class="line">===</div><div class="line"></div><div class="line"><span class="code">	1 = 1</span></div><div class="line"><span class="code">	@if(!isEmpty(name))&#123;</span></div><div class="line"><span class="code">	 and `name`=#name#</span></div><div class="line"><span class="code">	@&#125;</span></div><div class="line"><span class="code">	@if(!isEmpty(age))&#123;</span></div><div class="line"><span class="code">	 and `age`=#age#</span></div><div class="line"><span class="code">	@&#125;</span></div></pre></td></tr></table></figure>
<p>beetlsql生成了用于查询，更新，条件的sql片段和一个简单例子。你可以按照你的需要copy到sql模板文件里.实际上，如果你熟悉gen方法，你可以直接gen代码和sql到你的工程里，甚至是整个数据库都可以调用genAll来一次生成</p>
<blockquote>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>  sql 片段的生成顺序按照数据库表定义的顺序显示</p>
</blockquote>
<h3 id="3-BeetlSQL-说明"><a href="#3-BeetlSQL-说明" class="headerlink" title="3. BeetlSQL 说明"></a>3. BeetlSQL 说明</h3><h4 id="3-1-获得SQLManager"><a href="#3-1-获得SQLManager" class="headerlink" title="3.1. 获得SQLManager"></a>3.1. 获得SQLManager</h4><p>SQLManager 是系统的核心，他提供了所有的dao方法。获得SQLManager，可以直接构造SQLManager.并通过单例获取如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ConnectionSource source = ConnectionSourceHelper.getSimple(driver, url, <span class="string">""</span>, userName, password);</div><div class="line">DBStyle mysql = <span class="keyword">new</span> MySqlStyle();</div><div class="line"><span class="comment">// sql语句放在classpagth的/sql 目录下</span></div><div class="line">SQLLoader loader = <span class="keyword">new</span> ClasspathLoader(<span class="string">"/sql"</span>);</div><div class="line"><span class="comment">// 数据库命名跟java命名一样，所以采用DefaultNameConversion，还有一个是UnderlinedNameConversion，下划线风格的</span></div><div class="line">UnderlinedNameConversion nc = <span class="keyword">new</span>  UnderlinedNameConversion();</div><div class="line"><span class="comment">// 最后，创建一个SQLManager,DebugInterceptor 不是必须的，但可以通过它查看sql执行情况</span></div><div class="line">SQLManager sqlManager = <span class="keyword">new</span> SQLManager(mysql,loader,source,nc,<span class="keyword">new</span> Interceptor[]&#123;<span class="keyword">new</span> DebugInterceptor()&#125;);</div></pre></td></tr></table></figure>
<p>更常见的是，已经有了DataSource，创建ConnectionSource 可以采用如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ConnectionSource source = ConnectionSourceHelper.single(datasource);</div></pre></td></tr></table></figure>
<p>如果是主从Datasource</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ConnectionSource source = ConnectionSourceHelper.getMasterSlave(master,slaves)</div></pre></td></tr></table></figure>
<h4 id="3-2-查询API"><a href="#3-2-查询API" class="headerlink" title="3.2. 查询API"></a>3.2. 查询API</h4><h5 id="3-2-1-模板类查询（自动生成sql）"><a href="#3-2-1-模板类查询（自动生成sql）" class="headerlink" title="3.2.1. 模板类查询（自动生成sql）"></a>3.2.1. 模板类查询（自动生成sql）</h5><ul>
<li>public <t> List<t> all(Class<t> clazz) 查询出所有结果集</t></t></t></li>
<li>public <t> List<t> all(Class<t> clazz, int start, int size) 翻页</t></t></t></li>
<li>public int allCount(Class&lt;?&gt; clazz) 总数</li>
<li>public <t> List<t> template(T t) 根据模板查询，返回所有符合这个模板的数据库 同上，mapper可以提供额外的映射，如处理一对多，一对一</t></t></li>
<li>public <t>  T templateOne(T t) 根据模板查询，返回一条结果，如果没有找到，返回null</t></li>
<li>public <t> List<t> template(T t,int start,int size) 同上，可以翻页</t></t></li>
<li>public <t> long templateCount(T t) 获取符合条件的个数</t></li>
</ul>
<p>翻页的start，系统默认位从1开始，为了兼容各个数据库系统，会自动翻译成数据库习俗，比如start为1，会认为mysql，postgres从0开始（从start－1开始），oralce，sqlserver，db2从1开始（start－0）开始。</p>
<p>然而，如果你只用特定数据库，可以按照特定数据库习俗来，比如，你只用mysql，start为0代表起始纪录，需要配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OFFSET_START_ZERO = true</div></pre></td></tr></table></figure>
<p>这样，翻页参数start传入0即可。</p>
<p>注意:template查询方法根据模板查询并不包含时间字段，也不包含排序，然而，可以通过在pojo class上使用@TableTemplate() 或者日期字段的getter方法上使用@DateTemplate()来定制，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@TableTemplate</span>(<span class="string">"order by id desc "</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>  </span>&#123;</div><div class="line">	<span class="keyword">private</span> Integer id ;</div><div class="line">	<span class="keyword">private</span> Integer age ;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	<span class="meta">@DateTemplate</span>(accept=<span class="string">"minDate,maxDate"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> date;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，模板查询将添加order by id desc ,以及date字段将按照日期范围来查询。 具体参考annotation一章</p>
<h5 id="3-2-2-通过sqlid查询-sql语句在md文件里"><a href="#3-2-2-通过sqlid查询-sql语句在md文件里" class="headerlink" title="3.2.2. 通过sqlid查询,sql语句在md文件里"></a>3.2.2. 通过sqlid查询,sql语句在md文件里</h5><ul>
<li>public <t> List<t> select(String sqlId, Class<t> clazz, Map<string, object=""> paras) 根据sqlid来查询，参数是个map</string,></t></t></t></li>
<li>public <t> List<t> select(String sqlId, Class<t> clazz, Object paras) 根据sqlid来查询，参数是个pojo</t></t></t></li>
<li>public <t> List<t> select(String sqlId, Class<t> clazz) 根据sqlid来查询，无参数</t></t></t></li>
<li>public <t> List<t> select(String sqlId, Class<t> clazz, Map<string, object=""> paras, int start, int size)， 增加翻页</string,></t></t></t></li>
<li>public <t> List<t> select(String sqlId, Class<t> clazz, Object paras, int start, int size) ，增加翻页</t></t></t></li>
<li>public <t> T selectSingle(String id,Object paras, Class<t> target) 根据sqlid查询，输入是Pojo，将对应的唯一值映射成指定的taget对象，如果未找到，则返回空。需要注意的时候，有时候结果集本生是空，这时候建议使用unique</t></t></li>
<li>public <t> T selectSingle(String id,Map<string, object=""> paras, Class<t> target) 根据sqlid查询，输入是Map，将对应的唯一值映射成指定的taget对象，如果未找到，则返回空。需要注意的时候，有时候结果集本生是空，这时候建议使用unique</t></string,></t></li>
<li>public <t> T selectUnique(String id,Object paras, Class<t> target) 根据sqlid查询，输入是Pojo或者Map，将对应的唯一值映射成指定的taget对象,如果未找到，则抛出异常</t></t></li>
<li>public <t> T selectUnique(String id,Map<string, object=""> paras, Class<t> target) 根据sqlid查询，输入是Pojo或者Map，将对应的唯一值映射成指定的taget对象,如果未找到，则抛出异常</t></string,></t></li>
<li>public Integer intValue(String id,Object paras) 查询结果映射成Integer，如果找不到，返回null，输入是object</li>
<li>public Integer intValue(String id,Map paras) 查询结果映射成Integer，如果找不到，返回null，输入是map，其他还有 longValue，bigDecimalValue</li>
<li>public <t> T unique(Class<t> clazz,Object pk) 根据主键查询，如果未找到，抛出异常.</t></t></li>
</ul>
<h4 id="3-3-翻页查询API"><a href="#3-3-翻页查询API" class="headerlink" title="3.3. 翻页查询API"></a>3.3. 翻页查询API</h4><ul>
<li>public <t> void pageQuery(String sqlId,Class<t> clazz,PageQuery query)</t></t></li>
</ul>
<p>BeetlSQL 提供一个PageQUery对象,用于web应用的翻页查询,BeetlSql假定有sqlId 和sqlId$count,俩个sqlId,并用这来个来翻页和查询结果总数.如:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="section">queryNewUser</span></div><div class="line">===</div><div class="line">select * from user order by id desc ;</div><div class="line"></div><div class="line"><span class="section">queryNewUser$count</span></div><div class="line">===</div><div class="line">select count(1) from user</div></pre></td></tr></table></figure>
<p>对于俩个相似的sql语句,你可以使用use函数,把公共部分提炼出来.</p>
<p>大部分情况下,都不需要2个sql来完成,一个sql也可以,要求使用page函数或者pageTag标签,这样才能同时获得查询结果集总数和当前查询的结果</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="section">queryNewUser</span></div><div class="line">===</div><div class="line">select</div><div class="line">@pageTag()&#123;</div><div class="line">a.*,b.name role_name</div><div class="line">@&#125;</div><div class="line">from user a left join b ...</div></pre></td></tr></table></figure>
<p>如上sql,会在查询的时候转为俩条sql语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> <span class="keyword">user</span> a <span class="keyword">left</span> <span class="keyword">join</span> b...</div><div class="line"><span class="keyword">select</span> a.*,b.name role_name  <span class="keyword">from</span> <span class="keyword">user</span> a <span class="keyword">left</span> <span class="keyword">join</span> b...</div></pre></td></tr></table></figure>
<p>如果字段较多,为了输出方便,也可以使用pageTag,字段较少,用page函数也可以. ,具体参考pageTag和page函数说明.翻页代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从第一页开始查询,无参数</span></div><div class="line">PageQuery query = <span class="keyword">new</span> PageQuery();</div><div class="line">sql.pageQuery(<span class="string">"user.queryNewUser"</span>, User.class,query);</div><div class="line">System.out.println(query.getTotalPage());</div><div class="line">System.out.println(query.getTotalRow());</div><div class="line">System.out.println(query.getPageNumber());</div><div class="line">List&lt;User&gt; list = query.getList();</div></pre></td></tr></table></figure>
<p>PageQuery 对象也提供了 orderBy属性，用于数据库排序，如 “id desc”</p>
<blockquote>
<h4 id="跨数据库支持"><a href="#跨数据库支持" class="headerlink" title="跨数据库支持"></a>跨数据库支持</h4><p>  如果你打算使用PageQuery做翻页,且只想提供一个sql语句+page函数,那考虑到垮数据库,应该不要在这个sql语句里包含排序,因为大部分数据库都不支持. page函数生成的查询总数sql语句,因为包含了oder by,在大部分数据库都是会报错的的,比如:select count(1) form user order by name,在sqlserver,mysql,postgres都会出错,oracle允许这种情况, 因此,如果你要使用一条sql语句+page函数,建议排序用PageQuery对象里有排序属性oderBy,可用于排序,而不是放在sql语句里.</p>
<p>  2.8版本以后也提供了标签函数 pageIgnoreTag，可以用在翻页查询里，当查询用作统计总数的时候，会忽略标签体内容，如</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;   select page(&quot;*&quot;) from xxx </div><div class="line">&gt;   @pageIgnoreTag()&#123;</div><div class="line">&gt;    order by id </div><div class="line">&gt;   @&#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>  如上语句，在求总数的时候，会翻译成 select count(1) from xxx</p>
<p>  如果你不打算使用PageQuery+一条sql的方式,而是用俩条sql来分别翻页查询和统计总数,那无所谓</p>
<p>  或者你直接使用select 带有起始和读取总数的接口,也没有关系,可以在sql语句里包含排序</p>
</blockquote>
<h4 id="3-4-更新API"><a href="#3-4-更新API" class="headerlink" title="3.4. 更新API"></a>3.4. 更新API</h4><p>添加，删除和更新均使用下面的API</p>
<h5 id="3-4-1-自动生成sql"><a href="#3-4-1-自动生成sql" class="headerlink" title="3.4.1. 自动生成sql"></a>3.4.1. 自动生成sql</h5><ul>
<li>public void insert(Object paras) 插入paras到paras关联的表</li>
<li>public void insert(Object paras,boolean autoAssignKey) 插入paras到paras对象关联的表,并且指定是否自动将数据库主键赋值到paras里</li>
<li>public void insertTemplate(Object paras) 插入paras到paras关联的表,忽略为null值或者为空值的属性</li>
<li>public void insertTemplate(Object paras,boolean autoAssignKey) 插入paras到paras对象关联的表,并且指定是否自动将数据库主键赋值到paras里,忽略为null值或者为空值的属性，调用此方法，对应的数据库必须主键自增。</li>
<li>public void insert(Class&lt;?&gt; clazz,Object paras) 插入paras到clazz关联的表</li>
<li>public void insert(Class&lt;?&gt; clazz,Object paras,KeyHolder holder)，插入paras到clazz关联的表，如果需要主键，可以通过holder的getKey来获取，调用此方法，对应的数据库必须主键自增</li>
<li>public int insert(Class clazz,Object paras,boolean autoAssignKey) 插入paras到clazz关联的表，并且指定是否自动将数据库主键赋值到paras里，调用此方法，对应的数据库必须主键自增。</li>
<li>public int updateById(Object obj) 根据主键更新，所有值参与更新</li>
<li>public int updateTemplateById(Object obj) 根据主键更新，属性为null的不会更新</li>
<li>public int updateBatchTemplateById(Class clazz,List&lt;?&gt; list) 批量根据主键更新,属性为null的不会更新</li>
<li>public int updateTemplateById(Class&lt;?&gt; clazz，Map paras) 根据主键更新，组件通过clazz的annotation表示，如果没有，则认为属性id是主键,属性为null的不会更新。</li>
<li>public int[] updateByIdBatch(List&lt;?&gt; list) 批量更新</li>
<li>public void insertBatch(Class clazz,List&lt;?&gt; list) 批量插入数据</li>
</ul>
<h5 id="3-4-2-通过sqlid更新（删除）"><a href="#3-4-2-通过sqlid更新（删除）" class="headerlink" title="3.4.2. 通过sqlid更新（删除）"></a>3.4.2. 通过sqlid更新（删除）</h5><ul>
<li>public int insert(String sqlId,Object paras,KeyHolder holder) 根据sqlId 插入，并返回主键，主键id由paras对象所指定，调用此方法，对应的数据库表必须主键自增。</li>
<li>public int insert(String sqlId,Object paras,KeyHolder holder,String keyName) 同上，主键由keyName指定</li>
<li>public int insert(String sqlId,Map paras,KeyHolder holder,String keyName)，同上，参数通过map提供</li>
<li>public int update(String sqlId, Object obj) 根据sqlid更新</li>
<li>public int update(String sqlId, Map<string, object=""> paras) 根据sqlid更新，输出参数是map</string,></li>
<li>public int[] updateBatch(String sqlId,List&lt;?&gt; list) 批量更新</li>
<li>public int[] updateBatch(String sqlId,Map<string, object="">[] maps) 批量更新，参数是个数组，元素类型是map</string,></li>
</ul>
<h4 id="3-5-直接执行SQL模板"><a href="#3-5-直接执行SQL模板" class="headerlink" title="3.5. 直接执行SQL模板"></a>3.5. 直接执行SQL模板</h4><h5 id="3-5-1-直接执行sql模板语句"><a href="#3-5-1-直接执行sql模板语句" class="headerlink" title="3.5.1. 直接执行sql模板语句"></a>3.5.1. 直接执行sql模板语句</h5><p>  一下接口sql变量是sql模板</p>
<ul>
<li>public <t> List<t> execute(String sql,Class<t> clazz, Object paras)</t></t></t></li>
<li>public <t> List<t> execute(String sql,Class<t> clazz, Map paras)</t></t></t></li>
<li>public int executeUpdate(String sql,Object paras) 返回成功执行条数</li>
<li>public int executeUpdate(String sql,Map paras) 返回成功执行条数</li>
</ul>
<h4 id="3-5-2-直接执行JDBC-sql语句"><a href="#3-5-2-直接执行JDBC-sql语句" class="headerlink" title="3.5.2. 直接执行JDBC sql语句"></a>3.5.2. 直接执行JDBC sql语句</h4><ul>
<li>查询 public <t> List<t> execute(SQLReady p,Class<t> clazz) SQLReady包含了需要执行的sql语句和参数，clazz是查询结果，如</t></t></t></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;User&gt; list = sqlManager.execute(<span class="keyword">new</span> SQLReady(<span class="string">"select * from user where name=? and age = ?"</span>,<span class="string">"xiandafu"</span>,<span class="number">18</span>),User.class);)</div></pre></td></tr></table></figure>
<ul>
<li><p>更新 public int executeUpdate(SQLReady p) SQLReady包含了需要执行的sql语句和参数，返回更新结果</p>
</li>
<li><p>直接使用Connection public <t> T executeOnConnection(OnConnection<t> call),使用者需要实现onConnection方法的call方法，如调用存储过程</t></t></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String md5 = sql.executeOnConnection(<span class="keyword">new</span> OnConnection&lt;String&gt;()&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">		CallableStatement cstmt = conn.prepareCall(<span class="string">"&#123; ? = call md5( ? ) &#125;"</span>);</div><div class="line">		<span class="comment">// 其他代码</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="3-6-其他"><a href="#3-6-其他" class="headerlink" title="3.6. 其他"></a>3.6. 其他</h4><h5 id="3-6-1-强制使用主或者从"><a href="#3-6-1-强制使用主或者从" class="headerlink" title="3.6.1. 强制使用主或者从"></a>3.6.1. 强制使用主或者从</h5><ul>
<li>public void useMaster(DBRunner f) DBRunner里的beetlsql调用将使用主数据库库</li>
<li>public void useSlave(DBRunner f) DBRunner里的beetlsql调用将使用从数据库库</li>
</ul>
<h5 id="3-6-2-生成Pojo代码和SQ片段"><a href="#3-6-2-生成Pojo代码和SQ片段" class="headerlink" title="3.6.2. 生成Pojo代码和SQ片段"></a>3.6.2. 生成Pojo代码和SQ片段</h5><p>用于开发阶段根据表名来生成pojo代码和相应的sql文件</p>
<ul>
<li>genPojoCodeToConsole(String table), 根据表名生成pojo类，输出到控制台.</li>
<li>genSQLTemplateToConsole(String table),生成查询，条件，更新sql模板，输出到控制台。</li>
<li>genPojoCode(String table,String pkg,String srcPath,GenConfig config) 根据表名，包名，生成路径，还有配置，生成pojo代码</li>
<li>genPojoCode(String table,String pkg,GenConfig config) 同上，生成路径自动是项目src路径，或者src/main/java (如果是maven工程)</li>
<li>genPojoCode(String table,String pkg),同上，采用默认的生成配置</li>
<li>genSQLFile(String table), 同上，但输出到工程，成为一个sql模版,sql模版文件的位置在src目录下，或者src／main／resources（如果是maven）工程.</li>
<li>genALL(String pkg,GenConfig config,GenFilter filter) 生成所有的pojo代码和sql模版，</li>
<li>genBuiltInSqlToConsole(Class z) 根据类来生成内置的增删改查sql语句，并打印到控制台</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sql.genAll(<span class="string">"com.test"</span>, <span class="keyword">new</span> GenConfig(), <span class="keyword">new</span> GenFilter()&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(String tableName)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(tableName.equalsIgnoreCase(<span class="string">"user"</span>))&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// return false</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>第一个参数是pojo类包名，GenConfig是生成pojo的配置，GenFilter 是过滤，返回true的才会生成。如果GenFilter为null，则数据库所有表都要生成</p>
<blockquote>
<h4 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h4><p>  必须当心覆盖你掉你原来写好的类和方法，不要轻易使用genAll，如果你用了，最好立刻将其注释掉，或者在genFilter写一些逻辑保证不会生成所有的代码好sql模板文件</p>
</blockquote>
<h3 id="4-命名转化，表和列名映射"><a href="#4-命名转化，表和列名映射" class="headerlink" title="4. 命名转化，表和列名映射"></a>4. 命名转化，表和列名映射</h3><p>Beetlsql 默认提供了三种列明和属性名的映射类，推荐使用UnderlinedNameConversion</p>
<ul>
<li>DefaultNameConversion 数据库名和java属性名保持一致，如数据库表User，对应Java类也是User，数据库列是sysytemId,则java属性也是systemId，反之亦然</li>
<li>UnderlinedNameConversion 将数据库下划线去掉，首字母大写，如数据库是SYS_USER（oralce数据库的表和属性总是大写的), 则会改成SysUser</li>
<li>JPA2NameConversion 支持JPA方式的映射，适合不能用确定的映射关系(2.7.4以前采用JPANameConversion过于简单，已经不用了)</li>
<li>自定义命名转化，如果以上3个都不合适,可以自己实现一个命名转化。实现DefaultNameConversion实现方式</li>
<li>因为数据库表和列都忽略大小写区别，所以，实现NameConversion也不需要考虑大小写</li>
</ul>
<p>一般来讲，都建议数据库以下划线来区分单词，因此，使用UnderlinedNameConversion是个很好的选择</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultNameConversion</span> <span class="keyword">extends</span> <span class="title">NameConversion</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getTableName</span><span class="params">(Class&lt;?&gt; c)</span> </span>&#123;</div><div class="line">		Table table = (Table)c.getAnnotation(Table.class);</div><div class="line">		<span class="keyword">if</span>(table!=<span class="keyword">null</span>)&#123;</div><div class="line">			<span class="keyword">return</span> table.name();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> c.getSimpleName();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getColName</span><span class="params">(Class&lt;?&gt; c, String attrName)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> attrName;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getPropertyName</span><span class="params">(Class&lt;?&gt; c, String colName)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> colName;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有特殊的表并不符合DefaultNameConversion实现方式，你可以重新实现上面的三个方法</p>
<p>在使用org.beetl.sql.core.JPA2NameConversion作为命令转化规则时，你可以使用以下JPA标签来帮助解析实体类到数据库的转换:</p>
<ul>
<li>javax.persistence.Table</li>
<li>javax.persistence.Column</li>
<li>javax.persistence.Transient</li>
</ul>
<p>规则如下：<br>1 在类名前使用Table注解映射的表名，例如：@Table(name = “PF_TEST”)，表示映射的表名是PF_TEST；<br>2 忽略静态变量以及被@Transient注解的属性；<br>3 默认属性名与库表的字段名保持一致，如果不一致时，可以使用@Column注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Table</span>(name = <span class="string">"PF_TEST"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String S=<span class="string">"SSS"</span>;</div><div class="line">	<span class="meta">@Id</span></div><div class="line">  <span class="keyword">private</span> String id;</div><div class="line">	<span class="meta">@Column</span>(name = <span class="string">"login_name"</span>)</div><div class="line">    <span class="keyword">private</span> String loginName;</div><div class="line">    <span class="keyword">private</span> String password;</div><div class="line">    <span class="keyword">private</span> Integer age;</div><div class="line">    <span class="keyword">private</span> Long ttSize;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigger;</div><div class="line">    <span class="keyword">private</span> String biggerClob;</div><div class="line">    <span class="meta">@Transient</span></div><div class="line">    <span class="keyword">private</span> String biggerStr;</div><div class="line">    <span class="meta">@AssignID</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line">    getter setter...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-复合主键"><a href="#5-复合主键" class="headerlink" title="5. 复合主键"></a>5. 复合主键</h3><p>beetlsql 支持复合主键，无需像其他dao工具那样创建一个特别的主键对象，主键对象就是实体对象本生</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`party`</span> (</div><div class="line">  <span class="string">`id1`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`id2`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</div><div class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id1`</span>,<span class="string">`id2`</span>)</div><div class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=latin1;</div></pre></td></tr></table></figure>
<p>Party代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Party</span>  </span>&#123;</div><div class="line">	<span class="keyword">private</span> Integer id1 ;</div><div class="line">	<span class="keyword">private</span> Integer id2 ;</div><div class="line">	<span class="keyword">private</span> String name ;</div><div class="line">	<span class="comment">//忽略其他 getter setter方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据主键获取Party</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Party key = <span class="keyword">new</span> Party();</div><div class="line">key.setId1(<span class="number">1</span>);</div><div class="line">key.setId2(<span class="number">2</span>);</div><div class="line">Party party = sql.unique(Party.class, key);</div></pre></td></tr></table></figure>
<h3 id="6-使用Mapper"><a href="#6-使用Mapper" class="headerlink" title="6. 使用Mapper"></a>6. 使用Mapper</h3><p>SQLManager 提供了所有需要知道的API，但通过sqlid来访问sql有时候还是很麻烦，因为需要手敲字符串，另外参数不是map就是para，对代码理解没有好处，BeetlSql支持Mapper，将sql文件映射到一个interface。如下示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">User</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">// 使用"user.getCount"语句,无参数</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>;</div><div class="line">	<span class="comment">//使用"user.setUserStatus" 语句</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserStatus</span><span class="params">(Map paras)</span></span>; <span class="comment">//更新用户状态</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserAnnotherStatus</span><span class="params">(User user)</span></span>; <span class="comment">//更新用户状态</span></div><div class="line">	<span class="comment">//使用"user.findById", 传入参数id</span></div><div class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id)</span>;</div><div class="line">	<span class="comment">//or 使用params，一一对应</span></div><div class="line">	<span class="meta">@SqlStatement</span>(params=<span class="string">"id,status"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">findByIdAndStatus</span><span class="params">( Integer id,Integer status)</span></span>;</div><div class="line">	<span class="comment">//翻页查询，使用"user.queryNewUser"</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryNewUser</span><span class="params">(PageQuery query)</span> </span>;</div><div class="line">	<span class="comment">// 使用_st,_sz 翻页</span></div><div class="line">	<span class="meta">@SqlStatement</span>(params=<span class="string">"name,age,_st,_sz"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryUser</span><span class="params">( String name, Integer age,<span class="keyword">int</span> start, <span class="keyword">int</span> size)</span></span>;</div><div class="line">	<span class="comment">//使用sqlready</span></div><div class="line">	<span class="meta">@Sql</span>(value=<span class="string">" update user set age = ? where id = ? "</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAge</span><span class="params">(<span class="keyword">int</span> age,<span class="keyword">int</span> id)</span></span>;</div><div class="line"></div><div class="line">	<span class="meta">@Sql</span>(value=<span class="string">" select name from user"</span>,returnType=String.class)</div><div class="line">	<span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">allNames</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>Interface 可以继承BaseMapper，这样可以使用BaseMapper的一些公共方法，如insert，unqiue,single,updateById,deleteById等，也可以不继承</p>
</li>
<li><p>Interface里的方法名与Sql文件对应，如果方法名对应错了，会在调用的时候报错找不到sql。</p>
</li>
<li><p>方法参数可以是一个Object,或者是Map，这样，BeetlSql 自动识别为 sql的参数，也可以使用注解@Param来标注，或者混合这俩种情况 如:</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserStatus</span><span class="params">(Map paras,@Param(<span class="string">"name"</span>)</span> String name)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法如果是查询语句，可以使用@RowStart，@RowSize 作为翻页参数，BeetlSQL将自动完成翻页功能</p>
<p>注意 BeetlSQL 会根据 对应的方法对应的SQL语句，解析开头，如果是select开头，就认为是select操作，同理还有update，delete，insert。如果sql 模板不是以这些关键字开头，则需要使用注解 @SqlStatement</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SqlStatement</span>(type=SqlStatementType.INSERT)</div><div class="line"><span class="function"><span class="keyword">public</span> KeyHolder <span class="title">newUser</span><span class="params">(User user)</span></span>;<span class="comment">// 添加用户</span></div></pre></td></tr></table></figure>
<p>SqlStatement 也可在params申明参数名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryUser</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String name,@<span class="title">Param</span><span class="params">(<span class="string">"age"</span>)</span> Integer age,@RowStart <span class="keyword">int</span> start,@RowSize <span class="keyword">int</span> size)</span>;</div><div class="line"><span class="comment">// or</span></div><div class="line"><span class="meta">@SqlStatement</span>(params=<span class="string">"name,age,_st,_se"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryUser</span><span class="params">(String name,Integer age,<span class="keyword">int</span> start,<span class="keyword">int</span> size)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>查询语句返回的是List，则对应SQLManager.select</li>
<li>查询语句返回的是Pojo，原始类型等非List类型，则对应的SQLManager.selectSignle，如上面的getCount</li>
<li>insert 语句 如果有KeyHolder，则表示需要获取主键，对应SQLManager.insert(…​.,keyHolder)方法</li>
<li>参数列表里只允许有一个Pojo或者Map，作为查询参数_root，否则，需要加上@Param</li>
<li>参数列表里如果有List 或者Map[],则期望对应的是一个updateBatch操作</li>
<li>参数列表里如果@RowStart ,@RowSize,则认为是翻页语句</li>
<li>参数里如果有PageQuery,则认为是翻页查询</li>
<li>在查询中，返回的是List，但类型非Mapper指定的类型，无论是用@Sql ,还是 @SqlStatement，需要用returnType来说明，如上例子allNames 返回一个List<string>而不是List<user>,因此需要使用returnType做额外说明</user></string></li>
</ul>
<p>Mapper 也支持使用JDBC SQL，这时候需要采用Sql注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Sql</span>(value=<span class="string">" update user set age = ? where id = ? "</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateAge</span><span class="params">(<span class="keyword">int</span> age,<span class="keyword">int</span> id)</span></span>;</div><div class="line"><span class="meta">@Sql</span>(<span class="string">"select * from user  "</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>使用Mapper能增加Dao维护性，并能提高开发效率，建议在项目中使用。</p>
<p>对于Mapper涉及的查询来说，会将查询结果映射到返回值上，有如下规则</p>
<ul>
<li>Mapper方法得返回值应该查询结果对应，如查询结果是日期，方法返回值也应该是日期（Date或者Timestamp)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不需要注解说明返回类型</span></div><div class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getMaxDate</span><span class="params">(User query)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">@SqlStatement</span>(returnType=Date.class)</div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Date&gt; <span class="title">getTop10Date</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li><p>如果返回值是List，如实体本身集合，则不需要使用注解的returnType来说明，这是默认情况</p>
</li>
<li><p>如果返回的值是List，但是其他类型集合，则需要使用returnType来说明返回类型</p>
</li>
<li><p>翻页查询PageQuery 不需要做类型说明，默认返回就是实体本身，如果返回的是其他类型，也需要在returnType加以说明</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//翻页查询，默认返回实体对象</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryUser</span><span class="params">(PageQuery query)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="7-BeetlSQL-Annotation"><a href="#7-BeetlSQL-Annotation" class="headerlink" title="7. BeetlSQL Annotation"></a>7. BeetlSQL Annotation</h3><p>对于自动生成的sql，默认不需要任何annotaton，类名对应于表名（通过NameConverstion类），getter方法的属性名对应于列明（也是通过NameConverstion类），但有些情况还是需要anntation。</p>
<h4 id="7-1-AutoID-和-AssignID-，-SeqID"><a href="#7-1-AutoID-和-AssignID-，-SeqID" class="headerlink" title="7.1. @AutoID 和 @AssignID ，@SeqID"></a>7.1. @AutoID 和 @AssignID ，@SeqID</h4><ul>
<li>@AutoID,作用于getter方法，告诉beetlsql，这是自增主键,对应于数据自增长</li>
<li>@AssignID，作用于getter方法，告诉beetlsql，这是程序设定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AssignID</span>()</div><div class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> id;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码设定主键允许像@AssignID 传入id的生成策略以自动生成序列，beetl默认提供了一个snowflake算法，一个用于分布式环境的id生成器(<a href="https://github.com/twitter/snowflake" target="_blank" rel="external">https://github.com/twitter/snowflake</a>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AssignID</span>(<span class="string">"simple"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> id;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>simple 是beetlsql提供的一个默认的snowflake实现，你可以通过sqlManager自己注册id生成器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">sqlManager.addIdAutonGen(<span class="string">"uuid2"</span>, <span class="keyword">new</span> IDAutoGen()&#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">nextID</span><span class="params">(String params)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"hi"</span>+<span class="keyword">new</span> Random().nextInt(<span class="number">10000</span>);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AssignID</span>(<span class="string">"uuid2"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> id;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>@SeqID(name=”xx_seq”，作用于getter方法，告诉beetlsql，这是序列主键。</li>
</ul>
<p>对于属性名为id的自增主键，不需要加annotation，beetlsql默认就是@AutoID</p>
<blockquote>
<h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><ul>
<li>对于支持多种数据库的，这些annotation可以叠加在一起</li>
</ul>
</blockquote>
<h4 id="7-2-Tail"><a href="#7-2-Tail" class="headerlink" title="7.2. @Tail"></a>7.2. @Tail</h4><p>@Tail作用于类上，表示该对象是混合模型，参考下一章混合模型,sql查询无法在pojo映射的列或者结果集将使用Tail指定的方法</p>
<h4 id="7-3-ColumnIgnore"><a href="#7-3-ColumnIgnore" class="headerlink" title="7.3. @ColumnIgnore"></a>7.3. @ColumnIgnore</h4><p>在beetlsql 内置的insert或者update方法的时候，使用此注解的字段（作用于getter方法）将根据注解的属性来决定是否忽略此字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ColumnIgnore</span>(insert=<span class="keyword">true</span>,update=<span class="keyword">false</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getBir</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">return</span>  bir;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上例子，插入的时候忽略bir属性（往往是因为数据库指定了默认值为当前时间），更新的时候不能忽略 @ColumnIgnore的insert默认是true，update是false，因此也可以直接用 @ColumnIgnore()</p>
<h4 id="7-4-EnumMapping"><a href="#7-4-EnumMapping" class="headerlink" title="7.4. @EnumMapping"></a>7.4. @EnumMapping</h4><p>对于Entity使用了枚举作为属性值，可以再枚举类上定义EnumMapping，指出如何将枚举与数据库值互相转化，有四种方法</p>
<ul>
<li>如果没有使用@EnumMapping，则使用枚举的名称作为属性</li>
<li>@EnumMapping(EnumMapping.EnumType.STRING) 同上，使用枚举名称作为属性，数据库对应列应该是字符列</li>
<li>@EnumMapping(EnumMapping.EnumType.ORDINAL) 使用枚举的顺序作为属性，数据库对应列应该是int类型，用此作为映射需要防止重构枚举的时候导致数据库也重构，应该慎用</li>
<li>@EnumMapping(“xxx”)，如果不是上面的的定义，则beetlsql会查找枚举类的xxx属性，用这个值作为属性，比如</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EnumMapping</span>(<span class="string">"value"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</div><div class="line">	RED(<span class="string">"RED"</span>,<span class="number">1</span>),BLUE (<span class="string">"BLUE"</span>,<span class="number">2</span>);</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> value;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">	    <span class="keyword">this</span>.name = name;</div><div class="line">	    <span class="keyword">this</span>.value = value;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> value;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.value = value;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>beetlsq 会获取枚举的value属性（调用getValue)来获取枚举属性值</p>
<h4 id="7-5-Table"><a href="#7-5-Table" class="headerlink" title="7.5. @Table"></a>7.5. @Table</h4><p>标签 @Table(name=”xxxx”) 告诉beetlsql，此类对应xxxx表。比如数据库有User表，User类对应于User表，也可以创建一个UserQuery对象，也对应于User表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Table</span>(name=<span class="string">"user"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryUser</span> ..</span></div></pre></td></tr></table></figure>
<p>注：可以为对象指定一个数据库shcema，如name=”cms.user”,此时将访问cms库（或者cms用户，对不同的数据库，称谓不一样）下的user数据表</p>
<h4 id="7-6-TableTemplate"><a href="#7-6-TableTemplate" class="headerlink" title="7.6. @TableTemplate"></a>7.6. @TableTemplate</h4><ul>
<li>@TableTemplate() 用于模板查询，如果没有任何值，将按照主键降序排，也就是order by 主键名称 desc</li>
<li>@DateTemplate()，作用于日期字段的getter方法上，有俩个属性accept 和 compare 方法，分别表示 模板查询中，日期字段如果不为空，所在的日期范围，如</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@DateTemplate</span>(accept=<span class="string">"minDate,maxDate"</span>,compare=<span class="string">"&gt;=,&lt;"</span>)</div><div class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在模板查询的时候，将会翻译成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@if(!isEmpty(minDate))&#123;</div><div class="line"> and date&gt;=#minDate#</div><div class="line">@&#125;</div><div class="line">@if(!isEmpty(maxDate))&#123;</div><div class="line"> and date&lt;#maxDate#</div><div class="line">@&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><p>  minDate,maxDate 是俩个额外的变量,需要定义到pojo类里，DateTemplate也可以有默认值，如果@DateTemplate()，相当于@DateTemplate(accept=”min日期字段,max日期字段”,compare=”&gt;=,&lt;”)</p>
</blockquote>
<h4 id="7-7-Mapper相关注解"><a href="#7-7-Mapper相关注解" class="headerlink" title="7.7. Mapper相关注解"></a>7.7. Mapper相关注解</h4><p>Mapper 是将sql模板文件映射成一个具体的Dao方法类,这样方位代码开发和维护</p>
<p>Mapper中的注解，包括常用的    SqlStatement ，SqlStatementType ，Sql,Param 还有不常用的 RowSize ，RowStart，具体参考Mapper</p>
<h4 id="7-8-ORMQuery"><a href="#7-8-ORMQuery" class="headerlink" title="7.8. ORMQuery"></a>7.8. ORMQuery</h4><p>beetlsql 支持在实体类上增加ORMQuery注解,这样对于实体的查询,会触发懒加载,从而实现ORM 查询功能,具体参考ORM 查询一章</p>
<h3 id="8-BeetlSQL-数据模型"><a href="#8-BeetlSQL-数据模型" class="headerlink" title="8. BeetlSQL 数据模型"></a>8. BeetlSQL 数据模型</h3><p>BeetlSQL是一个全功能DAO工具，支持的模型也很全面，包括</p>
<ul>
<li>Pojo, 也就是面向对象Java Objec。Beetlsql操作将选取Pojoe属性和sql列的交集。额外属性和额外列将忽略.</li>
<li>Map/List, 对于一些敏捷开发，可以直接使用Map/List 作为输入输出参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;Map&lt;String,Object&gt;&gt; list = sqlManager.select(<span class="string">"user.find"</span>,Map.class,paras);</div></pre></td></tr></table></figure>
<ul>
<li>混合模型，推荐使用混合模型。兼具灵活性和更好的维护性。Pojo可以实现Tail（尾巴的意思)，或者继承TailBean，这样查询出的ResultSet 除了按照pojo进行映射外，无法映射的值将按照列表/值保存。如下一个混合模型:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*混合模型*/</span></div><div class="line"><span class="keyword">public</span> User extends TailBean&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id ;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> roleId;</div><div class="line">	<span class="comment">/*以下是getter和setter 方法*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于sql语句:</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="section">selectUser</span></div><div class="line">===</div><div class="line">select u.*,r.name r_name from user u left join role r on u.roleId=r.id .....</div></pre></td></tr></table></figure>
<p>执行查询的时候</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;User&gt; list = sqlManager.select(<span class="string">"user.selectUser"</span>,User.class,paras);</div><div class="line"><span class="keyword">for</span>(User user:list)&#123;</div><div class="line">	System.out.println(user.getId());</div><div class="line">	System.out.println(user.get(<span class="string">"rName"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序可以通过get方法获取到未被映射到pojo的值，也可以在模板里直接 ${user.rName} 显示（对于大多数模板引擎都支持）</p>
<p>另外一种更自由的实现混合模型的方法是在目标Pojo上采用注解@Tail，如果注解不带参数，则默认会调用set(String,Object) 方法来放置额外的查询属性，否则，依据注解的set参数来确定调用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Tail</span>(set=<span class="string">"addValue"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>  </span>&#123;</div><div class="line">	<span class="keyword">private</span> Integer id ;</div><div class="line">	<span class="keyword">private</span> Integer age ;</div><div class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">addValue</span><span class="params">(String str,Object ok)</span></span>&#123;</div><div class="line">		ext.put(str, ok);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h3 id="9-Markdown方式管理"><a href="#9-Markdown方式管理" class="headerlink" title="9. Markdown方式管理"></a>9. Markdown方式管理</h3><p>BeetlSQL集中管理SQL语句，SQL 可以按照业务逻辑放到一个文件里，文件名的扩展名是md或者sql。如User对象放到user.md 或者 user.sql里，文件可以按照模块逻辑放到一个目录下。文件格式抛弃了XML格式，采用了Markdown，原因是</p>
<ul>
<li>XML格式过于复杂，书写不方便</li>
<li>XML 格式有保留符号，写SQL的时候也不方便，如常用的&lt; 符号 必须转义</li>
<li>MD 格式本身就是一个文档格式，也容易通过浏览器阅读和维护</li>
</ul>
<p>目前SQL文件格式非常简单，仅仅是sqlId 和sql语句本身，如下</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">文件一些说明，放在头部可有可无，如果有说明，可以是任意文字</div><div class="line"><span class="section">SQL标示</span></div><div class="line">===</div><div class="line">以*开头的注释</div><div class="line">SQL语句</div><div class="line"></div><div class="line"><span class="section">SQL标示2</span></div><div class="line">===</div><div class="line">SQL语句 2</div></pre></td></tr></table></figure>
<p>注意:SQL语句从2.7.10版本后 sql部分也可以包含在markdow 的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">所有SQL文件建议放到一个sql目录，sql目录有多个子目录，表示数据库类型，这是公共SQL语句放到sql目录下，特定数据库的sql语句放到各自自目录下 当程序获取SQL语句得时候，先会根据数据库找特定数据库下的sql语句，如果未找到，会寻找sql下的。如下代码</div><div class="line"></div><div class="line">```java</div><div class="line">List&lt;User&gt; list = sqlManager.select(&quot;user.select&quot;,User.class);</div></pre></td></tr></table></figure></p>
<p>SqlManager 会根据当前使用的数据库，先找sql/mysql/user.md 文件，确认是否有select语句，如果没有，则会寻找sql/user.md</p>
<blockquote>
<h4 id="注"><a href="#注" class="headerlink" title="注"></a>注</h4><ul>
<li>注释是以* 开头，注释语句不作为sql语句</li>
<li>默认的ClasspathLoader采用了这种方法，你可以实现SQLLoader来实现自己的格式和sql存储方式，如数据库存储</li>
</ul>
</blockquote>
<h3 id="10-SQL-注释"><a href="#10-SQL-注释" class="headerlink" title="10. SQL 注释"></a>10. SQL 注释</h3><p>对于采用Markdown方式，可以采用多种方式对sql注释。</p>
<ul>
<li>采用sql 自己的注释符号，”– “ ,优点是适合java和数据库sql之间互相迁移，如</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span></div><div class="line"><span class="comment">--  status 代表状态</span></div><div class="line">statu = <span class="number">1</span></div></pre></td></tr></table></figure>
<ul>
<li>采用beetl注释</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span></div><div class="line">@ <span class="comment">/* 这些sql语句被注释掉</span></div><div class="line">statu = 1</div><div class="line">@ */</div></pre></td></tr></table></figure>
<ul>
<li>在sqlId 的=== 紧挨着的下一行 后面连续使用“*”作为sql整个语句注释</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="section">selectByUser</span></div><div class="line">==</div><div class="line"><span class="bullet">* </span>这个sql语句用来查询用户的</div><div class="line"><span class="bullet">* </span>status =1 表示查找有效用户</div><div class="line"></div><div class="line">select * from user where status = 1</div></pre></td></tr></table></figure>
<h3 id="11-重要-配置beetlsql"><a href="#11-重要-配置beetlsql" class="headerlink" title="11. (重要) 配置beetlsql"></a>11. (重要) 配置beetlsql</h3><p>beetlsql 配置文件是 btsql-ext.properties，位于classpath 根目录下，如果没有此文件，beetlsql将使用系统默认配置，如 <em> 是开发模式，beetlsql每次运行sql都会检测sql文件是否变化，并重新加载 </em> 字符集，是系统默认的字符集 * 翻页默认总是从1开始，对于oralce数据库来说，翻页起始参数正合适。对于mysql其他数据库来说，beetlsql，翻页参数变成n-1.一般你不需要关心</p>
<h4 id="11-1-开发模式和产品模式"><a href="#11-1-开发模式和产品模式" class="headerlink" title="11.1. 开发模式和产品模式"></a>11.1. 开发模式和产品模式</h4><p>beetlsql默认是开发模式，因此修改md的sql文件，不需要重启。但建议线上不要使用开发模式，因为此模式会每次sql调用都会检测md文件是否变化。可以通过修改/btsql-ext.properties ,修改如下属性改为产品模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PRODUCT_MODE = true</div></pre></td></tr></table></figure>
<h4 id="11-2-NameConversion"><a href="#11-2-NameConversion" class="headerlink" title="11.2. NameConversion"></a>11.2. NameConversion</h4><p>数据库字段名与java属性名的映射关系必须配置正确，否则会导致各种问题，如下是一些建议</p>
<p>字段名字是user_id, java属性名是userId, 则使用UnderlinedNameConversion 字段名是userId, java属性名是userId，则使用DefaultNameConversion</p>
<p>如果是其他映射关系，可以考虑自己实现NameConversion接口</p>
<h4 id="11-3-模板字符集"><a href="#11-3-模板字符集" class="headerlink" title="11.3. 模板字符集"></a>11.3. 模板字符集</h4><p>默认sql模板文件采用的是系统默认字符集，可以更改配置采用指定的字符集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CHARSET = UTF-8</div></pre></td></tr></table></figure>
<h4 id="11-4-翻页起始参数是0还是1"><a href="#11-4-翻页起始参数是0还是1" class="headerlink" title="11.4. 翻页起始参数是0还是1"></a>11.4. 翻页起始参数是0还是1</h4><p>默认认为1对应于翻页的第一条记录，如果你习惯mysql 那种0对应于第一条记录，则需要配置OFFSET_START_ZERO，设置为true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OFFSET_START_ZERO =  true</div></pre></td></tr></table></figure>
<p>无论是从0开始还是从开始，都不影响beetlsql根据特定数据库翻译成目标数据库的sql语句，这只是一个约定好的习惯，beetlsql会处理跨数据库翻页的</p>
<h4 id="11-5-自定义方法和标签函数"><a href="#11-5-自定义方法和标签函数" class="headerlink" title="11.5. 自定义方法和标签函数"></a>11.5. 自定义方法和标签函数</h4><p>可以在sql模板中使用自定义方法和标签函数，具体请参考beetl使用说明，如下是默认配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FN.use = org.beetl.sql.core.engine.UseFunction</div><div class="line">FN.globalUse = org.beetl.sql.core.engine.GlobalUseFunction</div><div class="line">FN.text = org.beetl.sql.core.engine.TextFunction</div><div class="line">FN.join = org.beetl.sql.ext.JoinFunction</div><div class="line">FN.isEmpty=org.beetl.sql.ext.EmptyExpressionFunction</div><div class="line">FN.page=org.beetl.sql.core.engine.PageQueryFuntion</div><div class="line">TAG.trim= org.beetl.sql.core.engine.TrimTag</div><div class="line">TAG.pageTag= org.beetl.sql.core.engine.PageQueryTag</div></pre></td></tr></table></figure>
<p>EmptyExpressionFunction 用在很多地方,如template 类操作,where语句里的条件判断,它 沿用了beetl习惯,对于不存在的变量,或者为null的变量,都返回true,同时如果是字符串,为空字符串也返回true,数组,集合也是这样,有些项目,认为空字符串应该算有值而不应该返回true,你可以参考EmptyExpressionFunction的实现,按照项目语义来定义isEmpty</p>
<h4 id="11-6-isEmpty-和-isNotEmpty"><a href="#11-6-isEmpty-和-isNotEmpty" class="headerlink" title="11.6. isEmpty 和 isNotEmpty"></a>11.6. isEmpty 和 isNotEmpty</h4><p>模板类查询和模板更新，以及Sql语句里的判断都依赖于isEmpty函数判断变量是否存在以及是否为null，2.8.4以前版本对空字符串也认为是空，2.8.4之后版本则仅仅判断对象是否存在以及是否为null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">where 1=1  </div><div class="line">@if(!isEmpty(connent))&#123;</div><div class="line">  and </div><div class="line">@&#125;</div></pre></td></tr></table></figure>
<p>如上代码，如果content存在，且不为null，则进入if代码块</p>
<p>如果想兼容以前的判断的方式，即认为空字符串也是空（不推荐这么用了），则需要在btsql-ext.properties，再次使以前的实现方式</p>
<p>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FN.isEmpty = org.beetl.ext.fn.EmptyExpressionFunction</div><div class="line">FN.isNotEmpty = org.beetl.ext.fn.IsNotEmptyExpressionFunction</div></pre></td></tr></table></figure>
<p>你也可以使用beetl的安全输出来表示，比如上面的sql代码，可以用安全输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">where 1=1  </div><div class="line">@if(null!=content!)&#123;</div><div class="line">  and </div><div class="line">@&#125;</div></pre></td></tr></table></figure>
<p>如上代码，content ! 是安全表达式，如果不存在或者为null，则为null，然后通过与null比较。</p>
<h3 id="12-SQL-模板基于Beetl实现"><a href="#12-SQL-模板基于Beetl实现" class="headerlink" title="12. SQL 模板基于Beetl实现"></a>12. SQL 模板基于Beetl实现</h3><p>SQL语句可以动态生成，基于Beetl语言，这是因为</p>
<ul>
<li>beetl执行效率高效 ，因此对于基于模板的动态sql语句，采用beetl非常合适</li>
<li>beetl 语法简单易用，可以通过半猜半式的方式实现，杜绝myBatis这样难懂难记得语法。BeetlSql学习曲线几乎没有</li>
<li>利用beetl可以定制定界符号，完全可以将sql模板定界符好定义为数据库sql注释符号，这样容易在数据库中测试，如下也是sql模板（定义定界符为”–:” 和 null,null是回车意思);</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="section">selectByCond</span></div><div class="line">===</div><div class="line">select * from user where 1=1</div><div class="line">--:if(age!=null)</div><div class="line">age=#age#</div><div class="line">--:&#125;</div></pre></td></tr></table></figure>
<ul>
<li>beetl 错误提示非常友好，减少写SQL脚本编写维护时间</li>
<li>beetl 能容易与本地类交互（直接访问Java类），能执行一些具体的业务逻辑 ，也可以直接在sql模板中写入模型常量，即使sql重构，也会提前解析报错</li>
<li>beetl语句易于扩展，提供各种函数，比如分表逻辑函数，跨数据库的公共函数等</li>
</ul>
<p>如果不了解beetl，可先自己尝试按照js语法来写sql模板，如果还有疑问，可以查阅官网 <a href="http://ibeetl.com/" target="_blank" rel="external">http://ibeetl.com</a></p>
<h3 id="13-Beetl-入门"><a href="#13-Beetl-入门" class="headerlink" title="13. Beetl 入门"></a>13. Beetl 入门</h3><p>Beetl 语法类似js，java，如下做简要说明，使用可以参考 <a href="http://ibeetl.com/" target="_blank" rel="external">http://ibeetl.com</a> , 或者在线体验 <a href="http://ibeetl.com/beetlonline/" target="_blank" rel="external">http://ibeetl.com/beetlonline/</a></p>
<h4 id="13-1-定界符号"><a href="#13-1-定界符号" class="headerlink" title="13.1. 定界符号"></a>13.1. 定界符号</h4><p>默认的定界符号是@ 和 回车。 里面可以放控制语句，表达式等语，，站位符号是##,站位符号默认是输出？，并在执行sql的传入对应的值。如果想在占位符号输出变量值，则需要使用text函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@if(!isEmpty(name))&#123;</div><div class="line">	and name = #name#</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果想修改定界符，可以增加一个/btsql-ext.properties. 设置如下属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DELIMITER_PLACEHOLDER_START=#</div><div class="line">DELIMITER_PLACEHOLDER_END=#</div><div class="line">DELIMITER_STATEMENT_START=@</div><div class="line">DELIMITER_STATEMENT_END=</div></pre></td></tr></table></figure>
<p>beetlsql 的其他属性也可以在此文件里设置</p>
<h4 id="13-2-变量"><a href="#13-2-变量" class="headerlink" title="13.2. 变量"></a>13.2. 变量</h4><p>通过程序传入的变量叫全局变量，可以在sql模板里使用，也可以定义变量，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">var</span> count = <span class="number">3</span>;</div><div class="line">@<span class="keyword">var</span> status = &#123;<span class="string">"a"</span>:<span class="number">1</span>&#125;  <span class="comment">//json变量</span></div></pre></td></tr></table></figure>
<h4 id="13-3-算数表达式"><a href="#13-3-算数表达式" class="headerlink" title="13.3. 算数表达式"></a>13.3. 算数表达式</h4><p>同js，如a+1-b%30, i++ 等</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> #<span class="string">'%'</span>+<span class="keyword">name</span>+<span class="string">'%'</span>#</div></pre></td></tr></table></figure>
<h4 id="13-4-逻辑表达式"><a href="#13-4-逻辑表达式" class="headerlink" title="13.4. 逻辑表达式"></a>13.4. 逻辑表达式</h4><p>有“&amp;&amp;” “||” ，还有 “！”，分别表示与，或，非， beetl也支持三元表达式</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="section">#user.gender==1?'女':'男'#</span></div></pre></td></tr></table></figure>
<h4 id="13-5-控制语句"><a href="#13-5-控制语句" class="headerlink" title="13.5. 控制语句"></a>13.5. 控制语句</h4><ul>
<li>if else 这个同java，c，js。</li>
<li>for,循环语句，如for(id:ids){}</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select * from user where status in (</div><div class="line">@for(id in ids)&#123;</div><div class="line"><span class="section">#id#  #text(idLP.last?"":"," )#</span></div><div class="line">@&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h4><ul>
<li>变量名＋LP 是一个内置变量，包含了循环状态，具体请参考beetl文档，text方法表示直接输出文本而不是符号“？”</li>
<li>关于 sql中的in，可以使用内置的join方法更加方便</li>
</ul>
</blockquote>
<ul>
<li>while 循环语句 ，如while(i&lt;count))</li>
</ul>
<h4 id="13-6-访问变量属性"><a href="#13-6-访问变量属性" class="headerlink" title="13.6. 访问变量属性"></a>13.6. 访问变量属性</h4><ul>
<li>如果是对象，直接访问属性名，user.name</li>
<li>如果是Map，用key访问 map[“key”];</li>
<li>如果是数组或者list，用索引访问，如list[1],list[i];</li>
<li>可以直采用java方式访问变量的方法和属性，如静态类Constatns</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constatns</span></span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> 	RUNNING = <span class="number">0</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接以java方式访问，需要再变量符号前加上@，可以在模板里访问</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">status</span> = #@Constatns.RUNNING# <span class="keyword">and</span> <span class="keyword">id</span> = #@Constatns.getUser().getId()#</div></pre></td></tr></table></figure>
<p>注意，如果Constants 类 没有导入进beetl，则需要带包名，导入beetl方法是配置IMPORT_PACKAGE=包名.;包名.</p>
<h4 id="13-7-判断对象非空空"><a href="#13-7-判断对象非空空" class="headerlink" title="13.7. 判断对象非空空"></a>13.7. 判断对象非空空</h4><p>可以采用isEmpty判断变量表达式是否为空(为null)，是否存在，如果是字符串，是否是空字符串，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(isEmpty(user)||isEmpty(role.name))</div></pre></td></tr></table></figure>
<p>也可以用传统方法判断，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(user==<span class="literal">null</span>) or <span class="keyword">if</span>(role.name!=<span class="literal">null</span>))</div></pre></td></tr></table></figure>
<p>变量有可能不存在，可用hasH函数或者需要使用安全输出符号，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="literal">null</span>==user.name!))</div><div class="line"><span class="comment">//or</span></div><div class="line"><span class="keyword">if</span>(has(user))</div></pre></td></tr></table></figure>
<p>变量表达式后面跟上”!” 表示如果变量不存在，则为！后面的值，如果！后面没有值，则为null</p>
<h4 id="13-8-调用方法"><a href="#13-8-调用方法" class="headerlink" title="13.8. 调用方法"></a>13.8. 调用方法</h4><p>同js，唯一值得注意的是，在占位符里调用text方法，会直接输出变量而不是“？”，其他以db开头的方式也是这样。架构师可以设置SQLPlaceholderST.textFunList.add(xxxx) 来决定那些方法在占位符号里可以直接输出文本而不是符号”?”</p>
<p>beetl提供了很多内置方法，如print，debug,isEmpty,date等，具体请参考文档</p>
<h4 id="13-9-自定义方法"><a href="#13-9-自定义方法" class="headerlink" title="13.9. 自定义方法"></a>13.9. 自定义方法</h4><p>通过配置btsql-ext.properties, 可以注册自己定义的方法在beetlsql里使用，如注册一个返回当前年份的函数，可以在btsql-ext.properties加如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FN.db.year= com.xxx.YearFunction</div></pre></td></tr></table></figure>
<p>这样在模板里,可以调用db.year() 获得当前年份。YearFunction 需要实现Function的 call方法，如下是个简单代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YearFunction</span> <span class="keyword">implements</span> <span class="title">Function</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Object[] paras, Context ctx)</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"2015"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于如何完成自定义方法，请参考 ibeetl 官方文档</p>
<h4 id="13-10-内置方法"><a href="#13-10-内置方法" class="headerlink" title="13.10. 内置方法"></a>13.10. 内置方法</h4><ul>
<li>print println 输出，同js，如print(“table1”);</li>
<li>has， 判断是否有此全局变量;</li>
<li>isEmpty 判断表达式是否为空，不存在，空字符串，空集合都返回true;</li>
<li>debug 将变量输出到控制台，如 debug(user);</li>
<li>text 输出，但可用于占位符号里</li>
<li>page 函数，用于在PageQuery翻页里，根据上下问决定输出count(1) 或者count(*),如果有参数，则按照参数输出</li>
<li>join, 用逗号连接集合或者数组，并输出？，用于in，如</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">status</span> <span class="keyword">in</span> ( #<span class="keyword">join</span>(ids)＃)</div><div class="line">			<span class="comment">-- 输出成  select * from user where status in (?,?,?)</span></div></pre></td></tr></table></figure>
<ul>
<li>use 参数是同一个md文件的sqlid，类似mybatis的 sql功能，如</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="section">condtion</span></div><div class="line">===</div><div class="line">where 1=1 and name = #name#</div><div class="line"></div><div class="line"><span class="section">selectUser</span></div><div class="line">===</div><div class="line">select * from user #use("condition")#</div></pre></td></tr></table></figure>
<p>globalUse 参数是其他文件的globalUse，如globalUse(“share.accessControl”),将访问share.md(sql)文件的accessControl片段</p>
<ul>
<li>db.dynamicSql类似use功能,但第一个参数是sql片段，而不是sqlId</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">queryUsers</span></div><div class="line">===</div><div class="line">@ var sql = "id=#xxx#";</div><div class="line">select #page("*")# from user where 1=1 and #db.dynamicSql(sql,&#123;xxx:1&#125;)#</div></pre></td></tr></table></figure>
<ul>
<li>page 用于pagequery,但beetlsql 使用pagequery查询,会将sql模板翻译成带有count(1),和列表名的俩个sql语句,因此必须使用page函数或者pageTag标签</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="section">queryNewUser</span></div><div class="line">===</div><div class="line">select #page()# from user</div></pre></td></tr></table></figure>
<p>如果无参数,则在查询的时候解释成 *,如果有参数,则解释成列名,如 page(“a.name,a.id,b.name role_name”) ,如果列名较多,可以使用pageTag</p>
<h4 id="13-11-标签功能"><a href="#13-11-标签功能" class="headerlink" title="13.11. 标签功能"></a>13.11. 标签功能</h4><ul>
<li>beetlsql 提供了trim标签函数，用于删除标签体最后一个逗号，这可以帮助拼接条件sql，如</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="section">updateStatus</span></div><div class="line">===</div><div class="line"></div><div class="line">update user set</div><div class="line">@trim()&#123;</div><div class="line">@if(!isEmpty(age)&#123;</div><div class="line">age = #age# ,</div><div class="line">@&#125; if(!isEmpty(status)&#123;</div><div class="line">status = #status#,</div><div class="line">@&#125;</div><div class="line">@&#125;</div><div class="line">where id = #id#</div></pre></td></tr></table></figure>
<p>trim 标签可以删除 标签体里的最后一个逗号.trim 也可以实现类似mybatis的功能，通过传入trim参数prefix，prefixOverrides来完成。具体参考标签api 文档</p>
<ul>
<li>pageTag,同page函数,用于pageQuery,如</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="section">queryNewUser</span></div><div class="line">===</div><div class="line">select</div><div class="line">@pageTag()&#123;</div><div class="line">id,name,status</div><div class="line">@&#125;</div><div class="line">from user</div></pre></td></tr></table></figure>
<p>注:可以参考beetl官网 了解如何开发自定义标签以及注册标签函数</p>
<ul>
<li>pageIgnoreTag，该标签的作用是在生成分页查询的count语句时，忽略sql语句里的某些内容，如：order by 。pageIgnoreTag与pageTag标签组合使用，组合如下</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="section">queryNewUser</span></div><div class="line">===</div><div class="line">select</div><div class="line">@pageTag()&#123;</div><div class="line">id,name,status</div><div class="line">@&#125;</div><div class="line">from user</div><div class="line">@pageIgnoreTag()&#123;</div><div class="line">order by a.createTime</div><div class="line">@&#125;</div></pre></td></tr></table></figure>
<p>因为count语句，无需要排序语句部分，而且，有些数据库，如SQLServer并不支持count语句被排序，因此可以使用pageIgnoreTag来解决夸数据库问题</p>
<ul>
<li>whereTag</li>
</ul>
<p>该标签复用TrimTag，其工作过程是：判断whereTag里的sql内容是否为空，如果为空就不输出空字符串，如果不为空则判断sql是否以AND或OR开头，如果是，则去掉。例如模板内容如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="section">queryNewUser</span></div><div class="line">===</div><div class="line">select a.* from user a </div><div class="line">@whereTag()&#123;</div><div class="line">@if(!isEmpty(age)&#123;</div><div class="line"><span class="code">    and a.age=#age# </span></div><div class="line">@&#125;</div><div class="line">@if(!isEmpty(status)&#123;</div><div class="line"><span class="code">    and a.status=#status#</span></div><div class="line">@&#125;</div><div class="line">@&#125;</div></pre></td></tr></table></figure>
<p>将生成</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> <span class="keyword">user</span> a </div><div class="line"><span class="keyword">where</span> </div><div class="line">a.age=? </div><div class="line"><span class="keyword">and</span> a.status=?</div></pre></td></tr></table></figure>
<p>当然，如果你不用whereTag，也可用where 1=1 来解决，我看并没有多大差别。</p>
<h3 id="14-Debug功能"><a href="#14-Debug功能" class="headerlink" title="14. Debug功能"></a>14. Debug功能</h3><p>Debug 期望能在控制台或者日志系统输出执行的sql语句，参数，执行结果以及执行时间，可以采用系统内置的DebugInterceptor 来完成，在构造SQLManager的时候，传入即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SqlManager sqlManager = <span class="keyword">new</span> SqlManager(source,mysql,loader,nc ,<span class="keyword">new</span> Interceptor[]&#123;<span class="keyword">new</span> DebugInterceptor() &#125;);</div></pre></td></tr></table></figure>
<p>或者通过spring，jfianl这样框架配置完成。使用后，执行beetlsql，会有类似输出</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">┏━━━━━ Debug [user.selectUserAndDepartment] ━━━</div><div class="line">┣ SQL：	 <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="number">1</span> = <span class="number">1</span></div><div class="line">┣ 参数：	 []</div><div class="line">┣ 位置：	 org.beetl.sql.test.QuickTest.main(QuickTest.java:<span class="number">47</span>)</div><div class="line">┣ 时间：	 <span class="number">23</span>ms</div><div class="line">┣ 结果：	 [<span class="number">3</span>]</div><div class="line">┗━━━━━ Debug [user.selectUserAndDepartment] ━━━</div></pre></td></tr></table></figure>
<p>beetlsql会分别输出 执行前的sql和参数，以及执行后的结果和耗费的时间。你可以参考DebugInterceptor 实现自己的调试输出</p>
<h3 id="15-缓存功能"><a href="#15-缓存功能" class="headerlink" title="15. 缓存功能"></a>15. 缓存功能</h3><p>同DebugInterceptor构造方式一样， SimpleCacheInterceptor能缓存指定的sql查询结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; lcs = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">lcs.add(<span class="string">"user"</span>);</div><div class="line">SimpleCacheInterceptor cache =<span class="keyword">new</span> SimpleCacheInterceptor(lcs);</div><div class="line">Interceptor[] inters = <span class="keyword">new</span> Interceptor[]&#123; <span class="keyword">new</span> DebugInterceptor(),cache&#125;;</div><div class="line">SQLManager 	sql = <span class="keyword">new</span> SQLManager(style,loader,cs,<span class="keyword">new</span> UnderlinedNameConversion(), inters);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</div><div class="line">	sql.select(<span class="string">"user.queryUser"</span>, User.class, <span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上例子，指定所有namespace为user查询都讲被缓存，如果此namepace有更新操作，则缓存清除，输出如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">┏━━━━━ Debug [user.queryUser] ━━━</div><div class="line">┣ SQL：	 <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">User</span> <span class="keyword">where</span> <span class="number">1</span> =<span class="number">1</span></div><div class="line">┣ 参数：	 []</div><div class="line">┣ 位置：	 org.beetl.sql.test.QuickTest.main(QuickTest.java:<span class="number">54</span>)</div><div class="line">┣ 时间：	 <span class="number">52</span>ms</div><div class="line">┣ 结果：	 [<span class="number">9</span>]</div><div class="line">┗━━━━━ Debug [user.queryUser] ━━━</div><div class="line"></div><div class="line">┏━━━━━ Debug [user.queryUser] ━━━</div><div class="line">┣ <span class="keyword">SQL</span>：	 <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">User</span> <span class="keyword">where</span> <span class="number">1</span> =<span class="number">1</span></div><div class="line">┣ 参数：	 []</div><div class="line">┣ 位置：	 org.beetl.sql.test.QuickTest.main(QuickTest.java:<span class="number">54</span>)</div><div class="line">┣ 时间：	 <span class="number">0</span>ms</div><div class="line">┣ 结果：	 [<span class="number">9</span>]</div><div class="line">┗━━━━━ Debug [user.queryUser] ━━━</div></pre></td></tr></table></figure>
<p>第二条查询的时间为0，这是因为直接使用了缓存缘故。</p>
<p>SimpleCacheInterceptor 构造的时候接受一个类列表，所有sqlid的namespace，比如“user.queryUser” 的namespace是“user”，如果beetlsql的查询sqlid此列表里，将参与缓存处理，否则，不参与缓存处理</p>
<p>默认的缓存实现是使用内存Map，也可以使用其他实现方式，比如redies，只需要实现如下接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheManager</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initCache</span><span class="params">(String ns)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putCache</span><span class="params">(String ns,Object key,Object value)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getCache</span><span class="params">(String ns,Object key)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCache</span><span class="params">(String ns)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containCache</span><span class="params">(String ns,Object key)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="16-Interceptor功能"><a href="#16-Interceptor功能" class="headerlink" title="16. Interceptor功能"></a>16. Interceptor功能</h3><p>BeetlSql可以在执行sql前后执行一系列的Intercetor，从而有机会执行各种扩展和监控，这比已知的通过数据库连接池做Interceptor更加容易。如下Interceptor都是有可能的</p>
<ul>
<li>监控sql执行较长时间语句，打印并收集。TimeStatInterceptor 类完成</li>
<li>对每一条sql语句执行后输出其sql和参数，也可以根据条件只输出特定sql集合的sql。便于用户调试。DebugInterceptor完成</li>
<li>对sql预计解析，汇总sql执行情况（未完成，需要集成第三方sql分析工具）</li>
</ul>
<p>你也可以自行扩展Interceptor类，来完成特定需求。 如下，在执行数据库操作前会执行befor，通过ctx可以获取执行的上下文参数，数据库成功执行后，会执行after方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(InterceptorContext ctx)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(InterceptorContext ctx)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>InterceptorContext 如下，包含了sqlId，实际得sql，和实际得参数, 也包括执行结果result。对于查询，执行结果是查询返回的结果集条数，对于更新，返回的是成功条数，如果是批量更新，则是一个数组。可以参考源码DebugInterceptor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorContext</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String sqlId;</div><div class="line">	<span class="keyword">private</span> String sql;</div><div class="line">	<span class="keyword">private</span>  List&lt;SQLParameter&gt; paras;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> isUpdate = <span class="keyword">false</span> ;</div><div class="line">	<span class="keyword">private</span> Object result ;</div><div class="line">	<span class="keyword">private</span> Map&lt;String,Object&gt; env  = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="17-内置支持主从数据库"><a href="#17-内置支持主从数据库" class="headerlink" title="17. 内置支持主从数据库"></a>17. 内置支持主从数据库</h3><p>BeetlSql管理数据源，如果只提供一个数据源，则认为读写均操作此数据源，如果提供多个，则默认第一个为写库，其他为读库。用户在开发代码的时候，无需关心操作的是哪个数据库，因为调用sqlScrip 的 select相关api的时候，总是去读取从库，add/update/delete 的时候，总是读取主库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sqlManager.insert(User.class,user) <span class="comment">// 操作主库，如果只配置了一个数据源，则无所谓主从</span></div><div class="line">sqlManager.unique(id,User.class) <span class="comment">//读取从库</span></div></pre></td></tr></table></figure>
<p>主从库的逻辑是由ConnectionSource来决定的，如下DefaultConnectionSource 的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConn</span><span class="params">(String sqlId,<span class="keyword">boolean</span> isUpdate,String sql,List&lt;?&gt; paras)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.slaves==<span class="keyword">null</span>||<span class="keyword">this</span>.slaves.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">this</span>.getWriteConn(sqlId,sql,paras);</div><div class="line">	<span class="keyword">if</span>(isUpdate) <span class="keyword">return</span> <span class="keyword">this</span>.getWriteConn(sqlId,sql,paras);</div><div class="line">	<span class="keyword">int</span> status  = forceStatus.get();</div><div class="line">	<span class="keyword">if</span>(status ==<span class="number">0</span>||status==<span class="number">1</span>)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getReadConn(sqlId, sql, paras);</div><div class="line">	&#125;<span class="keyword">else</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getWriteConn(sqlId,sql,paras);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>forceStatus 可以强制SQLManager 使用主或者从数据库。参考api SQLManager.useMaster(DBRunner f) ，SQLManager.useSlave(DBRunner f)</li>
</ul>
<p>对于于不同的ConnectionSource 完成逻辑不一样，对于spring，jfinal这样的框架，如果sqlManager在事务环境里，总是操作主数据库，如果是只读事务环境 则操作从数据库。如果没有事务环境，则根据sql是查询还是更新来决定。</p>
<p>如下是SpringConnectionSource 提供的主从逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConn</span><span class="params">(String sqlId,<span class="keyword">boolean</span> isUpdate,String sql,List paras)</span></span>&#123;</div><div class="line">	<span class="comment">//只有一个数据源</span></div><div class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.slaves==<span class="keyword">null</span>||<span class="keyword">this</span>.slaves.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">this</span>.getWriteConn(sqlId,sql,paras);</div><div class="line">	<span class="comment">//如果是更新语句，也得走master</span></div><div class="line">	<span class="keyword">if</span>(isUpdate) <span class="keyword">return</span> <span class="keyword">this</span>.getWriteConn(sqlId,sql,paras);</div><div class="line">	<span class="comment">//如果api强制使用</span></div><div class="line">	<span class="keyword">int</span> status  = forceStatus.get();</div><div class="line">	<span class="keyword">if</span>(status==<span class="number">1</span>)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getReadConn(sqlId, sql, paras);</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(status ==<span class="number">2</span>)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.getWriteConn(sqlId,sql,paras);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//在事物里都用master，除了readonly事物</span></div><div class="line">	<span class="keyword">boolean</span> inTrans = TransactionSynchronizationManager.isActualTransactionActive();</div><div class="line">	<span class="keyword">if</span>(inTrans)&#123;</div><div class="line">		<span class="keyword">boolean</span>  isReadOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();</div><div class="line">		<span class="keyword">if</span>(!isReadOnly)&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.getWriteConn(sqlId,sql,paras);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	 <span class="keyword">return</span> <span class="keyword">this</span>.getReadConn(sqlId, sql, paras);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，对于使用者来说，无需关心本节说的内容，仅仅供要定制主从逻辑的架构师。</p>
<h3 id="18-可以支持更复杂的分库分表逻辑"><a href="#18-可以支持更复杂的分库分表逻辑" class="headerlink" title="18. 可以支持更复杂的分库分表逻辑"></a>18. 可以支持更复杂的分库分表逻辑</h3><p>开发者也可以通过在Sql 模板里完成分表逻辑而对使用者透明，如下sql语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">insert</span> <span class="keyword">into</span></div><div class="line">#<span class="built_in">text</span>(<span class="string">"log_"</span>+ getMonth(<span class="built_in">date</span>())#</div><div class="line"><span class="keyword">values</span> () ...</div></pre></td></tr></table></figure>
<p>注：text函数直接输出表达式到sql语句，而不是输出？。</p>
<p>log表示按照一定规则分表，table可以根据输入的时间去确定是哪个表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span></div><div class="line">#<span class="built_in">text</span>(<span class="string">"log"</span>+log.date)#</div><div class="line"><span class="keyword">where</span></div></pre></td></tr></table></figure>
<blockquote>
<h4 id="注意-4"><a href="#注意-4" class="headerlink" title="注意"></a>注意</h4><p>  text函数直接输出表达式到sql语句，而不是输出？。</p>
</blockquote>
<p>同样，根据输入条件决定去哪个表，或者查询所有表</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@ var tables = getLogTables();</div><div class="line">@ for(table in tables)&#123;</div><div class="line">select * from #text(table)#</div><div class="line">@		if(!tableLP.isLast) print("union");</div><div class="line">@&#125;</div><div class="line">where name = #name#</div></pre></td></tr></table></figure>
<h3 id="19-跨数据库平台"><a href="#19-跨数据库平台" class="headerlink" title="19. 跨数据库平台"></a>19. 跨数据库平台</h3><p>如前所述，BeetlSql 可以通过sql文件的管理和搜索来支持跨数据库开发，如前所述，先搜索特定数据库，然后再查找common。另外BeetlSql也提供了一些夸数据库解决方案</p>
<ul>
<li>DbStyle 描述了数据库特性，注入insert语句，翻页语句都通过其子类完成，用户无需操心</li>
<li>提供一些默认的函数扩展，代替各个数据库的函数，如时间和时间操作函数date等</li>
<li>MySqlStyle mysql 数据库支持</li>
<li>OracleStyle oralce支持</li>
<li>PostgresStyle postgres数据库支持</li>
<li>其他还有SQLServer,H2,SQLLite ，DB2数据库支持</li>
</ul>
<h3 id="20-代码生成"><a href="#20-代码生成" class="headerlink" title="20. 代码生成"></a>20. 代码生成</h3><h4 id="20-1-生成pojo-和-md文件"><a href="#20-1-生成pojo-和-md文件" class="headerlink" title="20.1. 生成pojo 和 md文件"></a>20.1. 生成pojo 和 md文件</h4><p>​beetsql支持调用SQLManager.gen… 方法生成表对应的pojo类，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SQLManager sqlManager = <span class="keyword">new</span> SQLManager(style,loader,cs,<span class="keyword">new</span> DefaultNameConversion(), <span class="keyword">new</span> Interceptor[]&#123;<span class="keyword">new</span> DebugInterceptor()&#125;);</div><div class="line"><span class="comment">//sql.genPojoCodeToConsole("userRole"); 快速生成，显示到控制台</span></div><div class="line"><span class="comment">// 或者直接生成java文件</span></div><div class="line">GenConfig config = <span class="keyword">new</span> GenConfig();</div><div class="line">config.preferBigDecimal(<span class="keyword">true</span>);</div><div class="line">config.setBaseClass(<span class="string">"com.test.User"</span>);</div><div class="line">sqlManager.genPojoCode(<span class="string">"UserRole"</span>,<span class="string">"com.test"</span>,config);</div></pre></td></tr></table></figure>
<p>生成的路径位于工程的scr目录下，beetlsql自动判断是传统java项目还是maven项目，以使得生成的代码和sql放到正确的位置上。你也可以通过调用GenKit.setSrcPathRelativeToSrc 来设置代码生成路径，调用setResourcePathRelativeToSrc来设置生成的sql文件路径</p>
<p>config 类用来配置生成喜爱,目前支持生成pojo是否继承某个基类, 是否用BigDecimal代替Double,是否采用Date而不是Timestamp来表示日期，是否是直接输出到控制台而不是文件等 生成的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.test;</div><div class="line"><span class="keyword">import</span> java.math.*;</div><div class="line"><span class="keyword">import</span> java.sql.*;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRole</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">test</span>.<span class="title">User</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line"></div><div class="line">    <span class="comment">/* 数据库注释 */</span></div><div class="line">    <span class="keyword">private</span> String userName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以自己设定输出模版，通过GenConfig.initTemplate(String classPath),指定模版文件在classpath 的路径，或者直接设置一个字符串模版 GenConfig.initStringTemplate. 系统默认的模版如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> $&#123;<span class="keyword">package</span>&#125;;</div><div class="line">$&#123;imports&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">* $&#123;comment&#125;</div><div class="line">* gen by beetsql $&#123;date(),"yyyy-MM-dd"&#125;</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $</span>&#123;className&#125; $&#123;!isEmpty(ext)?<span class="string">"extends "</span>+ext&#125; &#123;</div><div class="line">	<span class="meta">@for</span>(attr in attrs)&#123;</div><div class="line">	@		<span class="keyword">if</span>(!isEmpty(attr.comment))&#123;</div><div class="line">	<span class="comment">//$&#123;attr.comment&#125;</span></div><div class="line">	@		&#125;</div><div class="line">	<span class="keyword">private</span> $&#123;attr.type&#125; $&#123;attr.name&#125; ;</div><div class="line">	@&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你需要给beetl模板注册函数等扩展，可以在生成sqlManager.genPojoCode之前，先注册扩展函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SourceGen.gt.registerFunction(<span class="string">"xxx"</span>,yourFunction)</div></pre></td></tr></table></figure>
<p>这样就可以再代码模板里使用扩展函数了</p>
<h4 id="20-2-生成更多的代码"><a href="#20-2-生成更多的代码" class="headerlink" title="20.2. 生成更多的代码"></a>20.2. 生成更多的代码</h4><p>可以实现MapperCodeGen的genCode接口，然后添加到 GenConfig里，这样再生成代码后，也会调用自定义的MapperCodeGen来生成更多代码。如系统内置的生成Mapper的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MapperCodeGen mapper = <span class="keyword">new</span> MapperCodeGen(<span class="string">"com.dao"</span>);</div><div class="line">config.codeGens.add(mapper);</div><div class="line">sql.genPojoCodeToConsole(<span class="string">"user"</span>, config);</div></pre></td></tr></table></figure>
<p>这样，除了生成pojo代码外，还生成mapper代码，内置的mapper代码实现如下，供参考</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperCodeGen</span> <span class="keyword">implements</span> <span class="title">CodeGen</span> </span>&#123;</div><div class="line">	String pkg = <span class="keyword">null</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MapperCodeGen</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MapperCodeGen</span><span class="params">(String pkg)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.pkg = pkg;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String mapperTemplate=<span class="string">""</span>;</div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		mapperTemplate = GenConfig.getTemplate(<span class="string">"/org/beetl/sql/ext/gen/mapper.btl"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genCode</span><span class="params">(String entityPkg, String entityClass, TableDesc tableDesc,GenConfig config,<span class="keyword">boolean</span> isDisplay)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span>(pkg==<span class="keyword">null</span>)&#123;</div><div class="line">			pkg = entityPkg;</div><div class="line">		&#125;</div><div class="line">		Template template = SourceGen.gt.getTemplate(mapperTemplate);</div><div class="line">		String mapperClass = entityClass+<span class="string">"Dao"</span>;</div><div class="line">		template.binding(<span class="string">"className"</span>, mapperClass);</div><div class="line">		template.binding(<span class="string">"package"</span>,pkg);</div><div class="line">		template.binding(<span class="string">"entityClass"</span>, entityClass);</div><div class="line"></div><div class="line">		String mapperHead = <span class="string">"import "</span>+entityPkg+<span class="string">".*;"</span>+SourceGen.CR;</div><div class="line">		template.binding(<span class="string">"imports"</span>, mapperHead);</div><div class="line">		String mapperCode = template.render();</div><div class="line">		<span class="keyword">if</span>(isDisplay)&#123;</div><div class="line">			System.out.println();</div><div class="line">			System.out.println(mapperCode);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				SourceGen.saveSourceFile(GenKit.getJavaSRCPath(), pkg, mapperClass, mapperCode);</div><div class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"mapper代码生成失败"</span>,e);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="21-直接使用SQLResult"><a href="#21-直接使用SQLResult" class="headerlink" title="21. 直接使用SQLResult"></a>21. 直接使用SQLResult</h3><p>有时候，也许你只需要SQL及其参数列表，然后传给你自己的dao工具类，这时候你需要SQLResult，它包含了你需要的sql，和sql参数。 SQLManager 有如下方法，你需要传入sqlid，和参数即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SQLResult <span class="title">getSQLResult</span><span class="params">(String id, Map&lt;String, Object&gt; paras)</span></span></div></pre></td></tr></table></figure>
<p>paras 是一个map，如果你只有一个pojo作为参数，你可以使用“_root” 作为key，这样sql模版找不到名称对应的属性值的时候，会寻找_root 对象，如果存在，则取其同名属性。</p>
<p>SQLResult 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLResult</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> String jdbcSql;</div><div class="line">	<span class="keyword">public</span> List&lt;SQLParameter&gt; jdbcPara;</div><div class="line">  	<span class="keyword">public</span> Object[] toObjectArray()&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>jdbcSql是渲染过后的sql，jdbcPara 是对应的参数描述，toObjectArray 是sql对应的参数值。</p>
<p>SQLParameter 用来描述参数，主要包含了</p>
<ul>
<li>value: 参数值</li>
<li>expression ，参数对应的表达式,如下sql</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = #<span class="keyword">id</span>#</div></pre></td></tr></table></figure>
<p>则expression 就是字符串id</p>
<ul>
<li><p>type，expression 类型，因为sql里有可能是一个复杂的表达式，因此type有如下值</p>
<p>NAME_GENEARL:简单的表达式，如id</p>
<p>NAME_EXPRESSION：复杂表达式，比如函数调用，逻辑运算表达式</p>
</li>
</ul>
<p>对于开发者来说，只需呀关心sql对应的参数值即可，因此可以调用toObjectArray得到。</p>
<h3 id="22-Hibernate-MyBatis-BeetlSQL-对比"><a href="#22-Hibernate-MyBatis-BeetlSQL-对比" class="headerlink" title="22. Hibernate,MyBatis,BeetlSQL 对比"></a>22. Hibernate,MyBatis,BeetlSQL 对比</h3><p><a href="https://my.oschina.net/xiandafu/blog/617542" target="_blank" rel="external">https://my.oschina.net/xiandafu/blog/617542</a> 提供了12项对比并给与评分。在犹豫使用BeetlSQL，可以参考这个全面的对比文章</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="static/beetlsql1.png" alt="beetlsql1" title="">
                </div>
                <div class="image-caption">beetlsql1</div>
            </figure>
<h3 id="23-ORM"><a href="#23-ORM" class="headerlink" title="23. ORM"></a>23. ORM</h3><blockquote>
<h4 id="注意-5"><a href="#注意-5" class="headerlink" title="注意"></a>注意</h4><ul>
<li>BeetlSql的Pojo类与数据库表对应，没有关系映射相关特性，除非Pojo实现@Tail 或者继承TailBean（或者实现Tail接口），额外的关系映射才会放到tail属性里供查询的时候调用。</li>
<li>要注意的是，beetlsql的orm 仅仅限于查询结果集，而不包括新增，更新，删除。这些需要调用sqlManager的api直接操作就行了而不像JPA那样还需要成为容器管理对象才能更新</li>
<li>无论是sql语句里配置orm查询,还是通过注解来配置orm查询,都不强求数据库一定有此映射关系,只要当运行调用的时候才会触发orm查询.对于eager查询,当调用beetlsql的时候,会触发ORM查询,对于lazy查询,并不会触发,只会在获取关系属性的时候的,再触发.</li>
</ul>
</blockquote>
<h4 id="23-1-sql语句里的ORM查询"><a href="#23-1-sql语句里的ORM查询" class="headerlink" title="23.1. sql语句里的ORM查询"></a>23.1. sql语句里的ORM查询</h4><p>beetlsql 关系映射是在sql语句里通过orm.single和 orm.many,orm.lazySingle,orm.lazyMany 函数进行申明。beetlsql会根据这些申明来完成关系映射</p>
<p>orm.single,orm.many ,orm.lazySingle,orm.lazyMany函数名字本身说明了是一对一，还是一对多或者多对多。以及是直接加载还是懒加载。函数可以放在sql语句任何地方，建议放到头部或者尾部，参数格式有俩种形式，</p>
<ul>
<li>使用模板方式查询关系对象，orm.single({“departmentId”,”id”},”Department”) 第一个参数申明了关系映射，即sql查询结果里属性（非字段名)，对应到关系表的查询属性， 如User对象里，departmentId应到Department对象的id，beetlsql会根据此关系发起一次template查询。映射的结果集放在第二个参数Department类里，如果Department与User类在同一个包下，可以省略包名，否则需要加上类包名</li>
<li>使用sqlId来查询关系对象，orm.single({“departmentId”,”id”},”user.selectDepatment”,”Department”) 第一个参数还是映射关系，第二个参数是一sql查询id，beetlsql将查询此sql语句，将结果集放到第三个参数Deparmtent类里</li>
<li>lazy 意味着当调用的时候再加载。如果在事务外调用，并不会像hibernate，JPA那样报错，beetlsql会再用一个数据库连接去查询。一般来讲，如果业务代码确定要用，建议不用lazy方式。因为lazy不会有查询优化，性能可能慢一些</li>
</ul>
<p>如上查询关系对象，均放到tail属性里，名称就是类名小写开头，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">User user = sqlManager.select(<span class="string">"user.selectUserAndDepartment"</span>,User.class,paras); Department dept = user.get(<span class="string">"department"</span>);</div></pre></td></tr></table></figure>
<p>如下是个例子，假设user表与department表示一对一关系，user.departmentId对应于deparment.id,因此关系映射是{“departmentId”:”id”} user与 role表示多对多关系，通过user_role做关联</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="section">selectUserAndDepartment</span></div><div class="line">===</div><div class="line"><span class="code">	select * from user where user_id=#userId#</span></div><div class="line"><span class="code">	@ orm.single(&#123;"departmentId":"id"&#125;,"Department");</span></div><div class="line"><span class="code">	@ orm.many(&#123;"id":"userId"&#125;,"user.selectRole","Role");</span></div><div class="line"></div><div class="line"><span class="section">user.selectRole</span></div><div class="line">===</div><div class="line"></div><div class="line"><span class="code">	select r.* from user_role ur left join role r on ur.role_id=r.id</span></div><div class="line"></div><div class="line"><span class="code">	where ur.user_id=#userId#</span></div></pre></td></tr></table></figure>
<p>java代码的样子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">User user = sqlManager.select(<span class="string">"user.selectUserAndDepartment"</span>,User.class,paras);</div><div class="line">Department dept = user.get(<span class="string">"department"</span>);</div><div class="line">List&lt;Role&gt; roles = user.get(<span class="string">"role"</span>);</div></pre></td></tr></table></figure>
<p>完整的orm查询例子可以参考 <a href="https://code.csdn.net/xiandafu/beetlsql_orm_sample/tree/master" target="_blank" rel="external">https://code.csdn.net/xiandafu/beetlsql_orm_sample/tree/master</a> 还有文档</p>
<p><a href="http://my.oschina.net/xiandafu/blog/735809" target="_blank" rel="external">http://my.oschina.net/xiandafu/blog/735809</a></p>
<blockquote>
<h4 id="注意-6"><a href="#注意-6" class="headerlink" title="注意"></a>注意</h4><p>  lazy方式只能继承TailBean才行，如果实现Tail接口，或者@Tail，你取出来的对象并不是你期望的Pojo，而是LazyEntity，你还需要调用get()方法获取到期数据库查询结果 ，可以参看TailBean代码来实现你的Lazy支持</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TailBean</span> <span class="keyword">implements</span> <span class="title">Tail</span> </span>&#123;</div><div class="line">	<span class="keyword">protected</span> Map&lt;String,Object&gt; extMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</div><div class="line">	<span class="keyword">boolean</span> hasLazy = <span class="keyword">false</span> ;</div><div class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(hasLazy)&#123;</div><div class="line">			Object o = extMap.get(key);</div><div class="line">			<span class="keyword">if</span>(o <span class="keyword">instanceof</span> LazyEntity )&#123;</div><div class="line">				LazyEntity lazyEntity = (LazyEntity)o;</div><div class="line">				<span class="keyword">try</span>&#123;</div><div class="line">					Object real = lazyEntity.get();</div><div class="line">					extMap.put(key, real);</div><div class="line">					<span class="keyword">return</span> real;</div><div class="line">				&#125;<span class="keyword">catch</span>(RuntimeException ex)&#123;</div><div class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeetlSQLException(BeetlSQLException.ORM_LAZY_ERROR,<span class="string">"Lazy Load Error:"</span>+key+<span class="string">","</span>+ex.getMessage(),ex);</div><div class="line">				&#125;</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				<span class="keyword">return</span> o;</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">return</span> extMap.get(key);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key,Object value)</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(value <span class="keyword">instanceof</span> LazyEntity )&#123;</div><div class="line">			hasLazy = <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">this</span>.extMap.put(key, value);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="23-2-ORM-注解"><a href="#23-2-ORM-注解" class="headerlink" title="23.2. ORM 注解"></a>23.2. ORM 注解</h4><p>不必要为每个sql语句写映射关系或者是使用一个公共的映射关系,可以在映射的实体类上注解映射关系从而实现懒加载机制,如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@OrmQuery</span>(</div><div class="line">value=&#123;</div><div class="line">	<span class="meta">@OrmCondition</span>(target=Department.class,attr=<span class="string">"departmentId"</span>,targetAttr=<span class="string">"id"</span>,type=OrmQuery.Type.ONE),</div><div class="line">	<span class="meta">@OrmCondition</span>(target=ProductOrder.class,attr=<span class="string">"id"</span>,targetAttr=<span class="string">"userId"</span> ,type=OrmQuery.Type.MANY),</div><div class="line">	<span class="meta">@OrmCondition</span>(target=Role.class,attr=<span class="string">"id"</span>,targetAttr=<span class="string">"userId"</span> ,sqlId=<span class="string">"user.selectRole"</span>,type=OrmQuery.Type.MANY)</div><div class="line"></div><div class="line">&#125;</div><div class="line">)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>   <span class="keyword">extends</span> <span class="title">TailBean</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Integer id ;</div><div class="line">	<span class="keyword">private</span> String name ;</div><div class="line">	<span class="keyword">private</span> Integer departmentId;</div><div class="line"></div><div class="line">	<span class="comment">//忽略getter setter</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OrmQuery 标注在类上,OrmCondition 声明了一个懒加载关系.因此,在以后beetlsql的关于此实体的查询,都可以进一步使用懒加载查询.</p>
<p>如果sql语句里也申明了ORM查询,则会和注解的里ORM注解做合并,遇到映射同一个实体,则以sql语句里的映射配置为准</p>
<h3 id="24-集成和Demo"><a href="#24-集成和Demo" class="headerlink" title="24. 集成和Demo"></a>24. 集成和Demo</h3><h4 id="24-1-Spring集成和Demo"><a href="#24-1-Spring集成和Demo" class="headerlink" title="24.1. Spring集成和Demo"></a>24.1. Spring集成和Demo</h4><p>集成提供了Mapper类的自动注入以及SQLManager的自动注入,以及与spring事务集成</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"beetlSqlScannerConfigurer"</span> <span class="attr">class</span>=<span class="string">"org.beetl.sql.ext.spring4.BeetlSqlScannerConfigurer"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 哪些类可以自动注入 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"org.beetl.sql.ext.spring4"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 通过类后缀 来自动注入Dao --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"daoSuffix"</span> <span class="attr">value</span>=<span class="string">"Dao"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlManagerFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlManagerFactoryBean"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlManagerFactoryBean"</span> <span class="attr">class</span>=<span class="string">"org.beetl.sql.ext.spring4.SqlManagerFactoryBean"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cs"</span> &gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">bean</span>  <span class="attr">class</span>=<span class="string">"org.beetl.sql.ext.spring4.BeetlSqlDataSource"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"masterSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dbStyle"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.beetl.sql.core.db.H2Style"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlLoader"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.beetl.sql.core.ClasspathLoader"</span>&gt;</span></div><div class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlRoot"</span> <span class="attr">value</span>=<span class="string">"/sql"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">	 <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"nc"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.beetl.sql.core.UnderlinedNameConversion"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptors"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.beetl.sql.ext.DebugInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>BeetlSqlScannerConfigurer 根据包名和类后缀来自动注入Dao类,如果没有Dao,可以不配置此项</li>
<li>cs: 指定ConnectionSource，可以用系统提供的DefaultConnectionSource，支持按照CRUD决定主从。例子里只有一个master库</li>
<li>dbStyle: 数据库类型，目前只支持org.beetl.sql.core.db.MySqlStyle，以及OralceSytle，PostgresStyle，SQLiteStyle，SqlServerStyle，H2Style</li>
<li>sqlLoader: sql语句加载来源</li>
<li>nc: 命名转化，有默认的DefaultNameConversion，数据库跟类名一致，还有有数据库下划线的UnderlinedNameConversion,JPANameConversion,</li>
<li>interceptors:DebugInterceptor 用来打印sql语句，参数和执行时间</li>
</ul>
<p>注意： 任何使用了Transactional 注解的，将统一使用Master数据源，例外的是@Transactional(readOnly=true),这将让Beetsql选择从数据库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceImpl</span> <span class="keyword">implements</span> <span class="title">MyService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Autowired</span></div><div class="line">    UserDao dao; <span class="comment">// mapper</span></div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    SQLManager sql;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="meta">@Transactional</span>()</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">total</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> total = list .size();</div><div class="line">		dao.deleteById(User.class, <span class="number">3</span>);</div><div class="line">		User u =<span class="keyword">new</span> User();</div><div class="line">		u.id = <span class="number">3</span>;</div><div class="line">		u.name=<span class="string">"hello"</span>;</div><div class="line">		u.age = <span class="number">12</span>;</div><div class="line">		dao.insert(User.class, u);</div><div class="line">		<span class="keyword">return</span> total;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其他集成配置还包括:</p>
<ul>
<li>functions 配置扩展函数</li>
<li>tagFactorys 配置扩展标签</li>
<li>configFileResource 扩展配置文件位置，beetlsql将读取此配置文件覆盖beetlsql默认选项</li>
<li>defaultSchema 数据库访问schema</li>
</ul>
<blockquote>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>可以参考demo <a href="https://git.oschina.net/xiandafu/springbeetlsql" target="_blank" rel="external">https://git.oschina.net/xiandafu/springbeetlsql</a></p>
</blockquote>
<h4 id="24-2-SpringBoot集成"><a href="#24-2-SpringBoot集成" class="headerlink" title="24.2. SpringBoot集成"></a>24.2. SpringBoot集成</h4><p>采用java config方式</p>
<p>参考 demo ，<a href="http://git.oschina.net/xiandafu/springboot_beetl_beetlsql" target="_blank" rel="external">http://git.oschina.net/xiandafu/springboot_beetl_beetlsql</a></p>
<p>spring boot集成需要注意的是要添加spring-devtools.properties文件,并配置如下选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">restart.include.beetl=/beetl-xxx.jar</div><div class="line">restart.include.beetlsql=/beetlsql-xxx..jar</div></pre></td></tr></table></figure>
<p>spring-devtools.properties 为spring boot的配置文件,位于META-INF目录下</p>
<h4 id="24-3-JFinal集成和Demo"><a href="#24-3-JFinal集成和Demo" class="headerlink" title="24.3. JFinal集成和Demo"></a>24.3. JFinal集成和Demo</h4><p>在configPlugin 里配置BeetlSql</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JFinalBeetlSql.init();</div></pre></td></tr></table></figure>
<p>默认会采用c3p0 作为数据源，其配置来源于jfinal 配置，如果你自己提供数据源或者主从，可以如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JFinalBeetlSql.init(master,slaves);</div></pre></td></tr></table></figure>
<p>由于使用了Beetlsql，因此你无需再配置 <strong>数据库连接池插件，和ActiveRecordPlugin</strong>,可以删除相关配置。</p>
<p>在controller里，可以通过JFinalBeetlSql.dao 方法获取到SQLManager</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SQLManager dao = JFinalBeetlSql.dao();</div><div class="line">BigBlog blog = getModel(BigBlog.class);</div><div class="line">dao.insert(BigBlog.class, blog);</div></pre></td></tr></table></figure>
<p>如果想控制事物，还需要注册Trans</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configInterceptor</span><span class="params">(Interceptors me)</span> </span>&#123;</div><div class="line">	me.addGlobalActionInterceptor(<span class="keyword">new</span> Trans());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后业务方法使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Before</span>(Trans.class)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doXXX</span><span class="params">()</span></span>&#123;....&#125;</div></pre></td></tr></table></figure>
<p>这样，方法执行完毕才会提交事物，任何RuntimeException将回滚，如果想手工控制回滚.也可以通过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Trans.commit()</div><div class="line">Trans.rollback()</div></pre></td></tr></table></figure>
<p>如果习惯了JFinal Record模式，建议用户创建一个BaseBean，封装SQLManager CRUD 方法即可。然后其他模型继承此BaseBean</p>
<blockquote>
<h4 id="注意-7"><a href="#注意-7" class="headerlink" title="注意"></a>注意</h4><p>  可以通过jfinal属性文件来配置sqlManager，比如 PropKit.use(“config.txt”, “UTF-8”),然后可以配置 sql.nc,sql.root，sql.interceptor，sql.dbStyle，具体参考源代码</p>
<p>  JFinalBeetlSql.initProp</p>
<h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><p>  可以参考demo <a href="https://git.oschina.net/xiandafu/jfinal_beet_beetsql_btjson" target="_blank" rel="external">https://git.oschina.net/xiandafu/jfinal_beet_beetsql_btjson</a></p>
<p>  demo <a href="https://code.csdn.net/xiandafu/beetlsql_orm_sample/tree/master" target="_blank" rel="external">https://code.csdn.net/xiandafu/beetlsql_orm_sample/tree/master</a></p>
</blockquote>
<h3 id="25-高级部分"><a href="#25-高级部分" class="headerlink" title="25. 高级部分"></a>25. 高级部分</h3><p>这章补充一下结果集和java类型的映射，以及事务管理</p>
<h4 id="25-1-ResultSet结果集到Bean的转化"><a href="#25-1-ResultSet结果集到Bean的转化" class="headerlink" title="25.1. ResultSet结果集到Bean的转化"></a>25.1. ResultSet结果集到Bean的转化</h4><p>数据库返回的ResultSet将根据Pojo对象的属性来做适当的转化，比如对于数据库如果定义了一个浮点类型，而Java端属性如果是double，则转成double，如果是BigDecimal，则转成BigDecial,如果定义为int类型，则转为int类型。BeanProcessor 类负责处理这种转化，开发者也可以实现自己的BeanProcessor来为特定的sql做转化，比如将数据库日期类型转为Java的Long类型。<br>如在BeanProcessor.createBean代码里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; propType = prop.getPropertyType();</div><div class="line">tp.setTarget(propType);</div><div class="line">JavaSqlTypeHandler handler = <span class="keyword">this</span>.handlers.get(propType);</div><div class="line"><span class="keyword">if</span>(handler==<span class="keyword">null</span>)&#123;</div><div class="line">	handler = <span class="keyword">this</span>.defaultHandler;</div><div class="line">&#125;</div><div class="line">Object value = handler.getValue(tp);</div><div class="line"><span class="keyword">this</span>.callSetter(bean, prop, value,propType);</div></pre></td></tr></table></figure>
<p>BeanProcessor 会根据属性类型取出对应的处理类，然后处理ResultSet，如果你先自定义处理类，你可以重新添加一个JavaSqlTypeHandler到handlers</p>
<h4 id="25-2-ResultSet结果集到Map的转化"><a href="#25-2-ResultSet结果集到Map的转化" class="headerlink" title="25.2. ResultSet结果集到Map的转化"></a>25.2. ResultSet结果集到Map的转化</h4><p>ResultSet转为Map的时候，有不一样则，根据数据库返回的列类型来做转化，数据库如果定义了一个浮点类型，则使用默认的BigDecimal类型</p>
<p>如在BeanProcessor.toMap代码里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">String columnName = rsmd.getColumnLabel(i);</div><div class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == columnName || <span class="number">0</span> == columnName.length()) &#123;</div><div class="line">  columnName = rsmd.getColumnName(i);</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> colType = rsmd.getColumnType(i);</div><div class="line">Class  classType = JavaType.jdbcJavaTypes.get(colType);</div><div class="line">JavaSqlTypeHandler handler = handlers.get(classType);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(handler==<span class="keyword">null</span>)&#123;</div><div class="line">	handler = <span class="keyword">this</span>.defaultHandler;</div><div class="line">&#125;</div><div class="line">tp.setIndex(i);</div><div class="line">tp.setTarget(classType);</div><div class="line">Object value = handler.getValue(tp);</div></pre></td></tr></table></figure>
<p>JavaType 定义了默认的数据库类型到Java类型的转化，从而获取适当的 JavaSqlTypeHandler，如果没有定义，则使用默认的handler，仅仅使用resultSet.getObject(i)来获取值<br>需要注意的是，尽量不要使用默认resultSet.getObject(i)来取值，这样会导致不同数据库取的类型不一样导致不兼容不同数据库。<br>JavaType已经定义了绝大部分数据库类型到Java类型的转化，少量很少使用的类型没有定义，直接使用resultSet.getObject(i)取值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//JavaType.java</span></div><div class="line"></div><div class="line">jdbcJavaTypes.put(<span class="keyword">new</span> Integer(Types.LONGNVARCHAR), String.class); <span class="comment">// -16</span></div><div class="line">																			<span class="comment">// 字符串</span></div><div class="line">jdbcJavaTypes.put(<span class="keyword">new</span> Integer(Types.NCHAR), String.class); <span class="comment">// -15 字符串</span></div><div class="line">jdbcJavaTypes.put(<span class="keyword">new</span> Integer(Types.NVARCHAR), String.class); <span class="comment">// -9 字符串</span></div><div class="line">jdbcJavaTypes.put(<span class="keyword">new</span> Integer(Types.ROWID), String.class); <span class="comment">// -8 字符串</span></div><div class="line">jdbcJavaTypes.put(<span class="keyword">new</span> Integer(Types.BIT), Boolean.class); <span class="comment">// -7 布尔</span></div><div class="line">jdbcJavaTypes.put(<span class="keyword">new</span> Integer(Types.TINYINT), Integer.class); <span class="comment">// -6 数字</span></div><div class="line">jdbcJavaTypes.put(<span class="keyword">new</span> Integer(Types.BIGINT), Long.class); <span class="comment">// -5 数字</span></div><div class="line">jdbcJavaTypes.put(<span class="keyword">new</span> Integer(Types.LONGVARBINARY), <span class="keyword">byte</span>[].class); <span class="comment">// -4</span></div><div class="line">																	<span class="comment">// 二进制</span></div><div class="line">jdbcJavaTypes.put(<span class="keyword">new</span> Integer(Types.VARBINARY), <span class="keyword">byte</span>[].class); <span class="comment">// -3 二进制</span></div><div class="line">jdbcJavaTypes.put(<span class="keyword">new</span> Integer(Types.BINARY), <span class="keyword">byte</span>[].class); <span class="comment">// -2 二进制</span></div><div class="line">jdbcJavaTypes.put(<span class="keyword">new</span> Integer(Types.LONGVARCHAR), String.class); <span class="comment">// -1</span></div><div class="line"></div><div class="line">......</div></pre></td></tr></table></figure>
<p>有些框架，在使用Map的时候，添加了更多的灵活性，比如通过columnName 来片段是否该字段是字典字段，比如豆油后缀”_dict”,如果是，则从缓存或者查询响应的字典数据，放到ThreadLocal里，以一次性将查询结果，相关字典数据返回</p>
<h4 id="25-3-PreparedStatment"><a href="#25-3-PreparedStatment" class="headerlink" title="25.3. PreparedStatment"></a>25.3. PreparedStatment</h4><p>BeanProcessor.setPreparedStatementPara用于JDBC设置参数，内容如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">setPreparedStatementPara</span><span class="params">(String sqlId,PreparedStatement ps,List&lt;SQLParameter&gt; objs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objs.size(); i++) &#123;</div><div class="line">			SQLParameter para = objs.get(i);</div><div class="line">			Object o = para.value;</div><div class="line">			<span class="keyword">if</span>(o==<span class="keyword">null</span>)&#123;</div><div class="line">				ps.setObject(i + <span class="number">1</span>, o);</div><div class="line">				<span class="keyword">continue</span> ;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// 兼容性修改：oralce 驱动 不识别util.Date</span></div><div class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.dbName.equals(<span class="string">"oracle"</span>))&#123;</div><div class="line">				Class c = o.getClass();</div><div class="line">				<span class="keyword">if</span>(c== java.util.Date.class)&#123;</div><div class="line">					o = <span class="keyword">new</span> Timestamp(((java.util.Date) o).getTime());</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			<span class="keyword">if</span>(Enum.class.isAssignableFrom(o.getClass()))&#123;</div><div class="line">				o = EnumKit.getValueByEnum(o);</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			<span class="comment">//clob or text</span></div><div class="line">			<span class="keyword">if</span>(o.getClass()==<span class="keyword">char</span>[].class)&#123;</div><div class="line">				o = <span class="keyword">new</span> String((<span class="keyword">char</span>[])o);</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			</div><div class="line">			<span class="keyword">int</span> jdbcType = para.getJdbcType();</div><div class="line">			<span class="keyword">if</span>(jdbcType==<span class="number">0</span>)&#123;</div><div class="line">				ps.setObject(i + <span class="number">1</span>, o);</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				<span class="comment">//通常一些特殊的处理</span></div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(jdbcType+<span class="string">",默认处理器并未处理此jdbc类型"</span>);</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>#### </p>
<p>SQLParameter 包含了sql对应参数的值，也包含参数对应的变量名，如果该变量还有类型说明，则jdbcType不为0，如下某个sql</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from user where create_time&gt;#createTime,typeofDate#</div></pre></td></tr></table></figure>
<p>此时，SQLParameter.value 是createTime对应的值，SQLParameter.expression是字符串”createTime”,</p>
<p>由于使用了typeof开头的格式化函数，typeofDate 意思是指此值应当着java.sql.Types.Date 来处理（然而，默认的BeanProcessor 并不会处理SQLParameter.jdbcType）</p>
<h4 id="25-4-自定义BeanProcessor"><a href="#25-4-自定义BeanProcessor" class="headerlink" title="25.4. 自定义BeanProcessor"></a>25.4. 自定义BeanProcessor</h4><p>你可以为Beeetsql指定一个默认的BeanProcessor，也可以为某些特定的sqlid指定BeanProcessor，SqlManager提供了俩个方法来完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultBeanProcessors</span><span class="params">(BeanProcessor defaultBeanProcessors)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.defaultBeanProcessors = defaultBeanProcessors;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProcessors</span><span class="params">(Map&lt;String, BeanProcessor&gt; processors)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.processors = processors;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="25-5-事务管理"><a href="#25-5-事务管理" class="headerlink" title="25.5. 事务管理"></a>25.5. 事务管理</h4><p>BeetlSql 是一个简单的Dao工具，不含有事务管理，完全依赖web框架的事务管理机制，监听开始事务，结束事务等事件，如果你使用Spring，JFinal框架，无需担心事务，已经集成好了，如果你没有这些框架，也可以用Beetlsq</p>
<p>提供的DSTransactionManager 来指定事务边界，是事实，Spring的事务集成也使用了DSTransactionManager</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SQLManager 	sql = <span class="keyword">new</span> SQLManager(style,loader,cs,<span class="keyword">new</span> UnderlinedNameConversion(), inters);</div><div class="line">.......</div><div class="line">DSTransactionManager.start();</div><div class="line">User user = <span class="keyword">new</span> User();</div><div class="line">sql.insert(user);</div><div class="line">sql.insert(user);</div><div class="line">DSTransactionManager.commit();</div></pre></td></tr></table></figure>
<blockquote>
<p>注意:ConnectionSourceHelper.getSimple() 获得的是一个简单的cs，没有事务管理器参与，建议你用</p>
<p>getSingle(DataSource ds),返回DefaultConnectionSource具备事务管理。</p>
</blockquote>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-04-19T12:55:38.000Z" itemprop="dateUpdated">2017-04-19 20:55:38</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2017/04/19/beetlsql/" target="_blank" rel="external">http://yoursite.com/2017/04/19/beetlsql/</a>
        
    </div>
    <footer>
        <a href="http://yoursite.com">
            <img src="/img/avatar.jpg" alt="张瑞宇">
            张瑞宇
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sql/">sql</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2017/04/19/beetlsql/&title=《My New Post》 — 张大头的博客&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2017/04/19/beetlsql/&title=《My New Post》 — 张大头的博客&source=深井宇的..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2017/04/19/beetlsql/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《My New Post》 — 张大头的博客&url=http://yoursite.com/2017/04/19/beetlsql/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2017/04/19/beetlsql/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/04/19/beetlsql 2/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">My New Post</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/04/19/android虚线/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">android虚线</h4>
      </a>
    </div>
  
</nav>



    

<div class="comments" id="comments">
    <div class="ds-thread" data-thread-key="beetlsql" data-title="My New Post" data-url="http://yoursite.com/2017/04/19/beetlsql/"></div>
</div>
<script>
lazyScripts.push('//cdn.bootcss.com/marked/0.3.6/marked.min.js');

var duoshuoQuery = {short_name:'ysblog', theme: 'none'};
lazyScripts.push('//unpkg.com/hexo-theme-material-indigo@latest/js/embed.min.js');


</script>










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <ul class="reward-items">
        
        <li>
            <img src="/img/wechat.jpg" title="微信打赏二维码" alt="微信打赏二维码">
            <p>微信</p>
        </li>
        

        
        <li>
            <img src="/img/alipay.jpg" title="支付宝打赏二维码" alt="支付宝打赏二维码">
            <p>支付宝</p>
        </li>
        
    </ul>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>博客内容遵循<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p>
            <span>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></span>
            <span>张瑞宇 &copy; 2015 - 2017</span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2017/04/19/beetlsql/&title=《My New Post》 — 张大头的博客&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2017/04/19/beetlsql/&title=《My New Post》 — 张大头的博客&source=深井宇的..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2017/04/19/beetlsql/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《My New Post》 — 张大头的博客&url=http://yoursite.com/2017/04/19/beetlsql/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2017/04/19/beetlsql/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://yoursite.com/2017/04/19/beetlsql/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };



</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
